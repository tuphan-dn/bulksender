{"version":3,"file":"static/js/src_os_store_devTools_ts-src_os_store_mints_reducer_ts-src_os_view_wallet_lib_cloverWallet_ts-47ddb7.6b7133cd.chunk.js","mappings":"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","sources":["os/configs/sol.config.ts","os/configs/register.config.ts","os/configs/index.ts","os/store/devTools.ts","os/store/mints.reducer.ts","os/view/wallet/lib/baseWallet.ts","os/view/wallet/lib/cloverWallet.ts","os/view/wallet/lib/coin98Wallet.ts","os/view/wallet/lib/guestWallet.ts","os/view/wallet/lib/phantomWallet.ts","shared/session.ts","os/view/wallet/lib/secretkeyWallet.ts","os/view/wallet/lib/slopeWallet.ts","os/view/wallet/lib/solflareExtWallet.ts","os/view/wallet/lib/solflareWebWallet.ts","os/view/wallet/lib/solletWebWallet.ts","shared/pdb/index.ts","shared/pdb/ipfs.ts"],"sourcesContent":["import { Net, rpc } from 'shared/runtime'\n\nconst SOLVARS = {\n  spltAddress: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  splataAddress: 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n}\n\n/**\n * Contructor\n */\ntype Conf = {\n  node: string\n  swapAddress: string\n  taxmanAddress: string\n} & typeof SOLVARS\n\nconst conf: Record<Net, Conf> = {\n  /**\n   * Development configurations\n   */\n  devnet: {\n    ...SOLVARS,\n    node: rpc,\n    swapAddress: '4erFSLP7oBFSVC1t35jdxmbfxEhYCKfoM6XdG2BLR3UF',\n    taxmanAddress: '8UaZw2jDhJzv5V53569JbCd3bD4BnyCfBH3sjwgajGS9',\n  },\n\n  /**\n   * Staging configurations\n   */\n  testnet: {\n    ...SOLVARS,\n    node: rpc,\n    swapAddress: '4erFSLP7oBFSVC1t35jdxmbfxEhYCKfoM6XdG2BLR3UF',\n    taxmanAddress: '8UaZw2jDhJzv5V53569JbCd3bD4BnyCfBH3sjwgajGS9',\n  },\n\n  /**\n   * Production configurations\n   */\n  mainnet: {\n    ...SOLVARS,\n    node: rpc,\n    swapAddress: 'SSW7ooZ1EbEognq5GosbygA3uWW1Hq1NsFq6TsftCFV',\n    taxmanAddress: '9doo2HZQEmh2NgfT3Yx12M89aoBheycYqH1eaR5gKb3e',\n  },\n}\n\n/**\n * Module exports\n */\nexport default conf\n","import { Env } from 'shared/runtime'\n\nif (\n  typeof process.env.REACT_APP_ID !== 'string' ||\n  typeof process.env.REACT_APP_NAME !== 'string' ||\n  typeof process.env.REACT_APP_URL !== 'string'\n)\n  throw new Error(\n    'Please add REACT_APP_ID, REACT_APP_NAME, REACT_APP_URL in .env.local!',\n  )\n\n/**\n * Contructor\n */\n\ntype Conf = {\n  devAppId: string\n  extra: SenReg\n  senreg: string\n}\n\nconst DEFAULT_APP_ID = process.env.REACT_APP_ID\nconst devApp = {\n  [DEFAULT_APP_ID]: {\n    url: process.env.REACT_APP_URL,\n    appId: DEFAULT_APP_ID,\n    name: process.env.REACT_APP_NAME,\n    author: {\n      name: process.env.REACT_APP_AUTHOR_NAME || '',\n      email: process.env.REACT_APP_AUTHOR_EMAIL || '',\n    },\n    tags: (process.env.REACT_APP_TAGS || '')\n      .split(',')\n      .map((tag) => tag.trim()),\n    description: process.env.REACT_APP_DESCRIPTION || '',\n    verified: false,\n  },\n}\n\nconst conf: Record<Env, Conf> = {\n  /**\n   * Development configurations\n   */\n  development: {\n    devAppId: DEFAULT_APP_ID,\n    extra: devApp,\n    senreg: 'https://descartesnetwork.github.io/senreg/register.json',\n  },\n\n  /**\n   * Staging configurations\n   */\n  staging: {\n    devAppId: DEFAULT_APP_ID,\n    extra: devApp,\n    senreg: 'https://descartesnetwork.github.io/senreg/register.json',\n  },\n\n  /**\n   * Production configurations\n   */\n  production: {\n    devAppId: DEFAULT_APP_ID,\n    extra: {},\n    senreg: 'https://descartesnetwork.github.io/senreg/register.json',\n  },\n}\n\n/**\n * Module exports\n */\nexport default conf\n","import { net, env } from 'shared/runtime'\nimport sol from './sol.config'\nimport register from './register.config'\n\nconst configs = {\n  sol: sol[net],\n  register: register[env],\n}\n\n/**\n * Module exports\n */\nexport default configs\n","import { PublicKey } from '@solana/web3.js'\nimport BN from 'bn.js'\n\n// Bugfix performance\n// https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/Troubleshooting.md#excessive-use-of-memory-and-cpu\nexport const devTools = (appName: string): any => {\n  if (process.env.REACT_APP_ENV !== 'development') return false\n  return {\n    name: appName,\n    actionSanitizer: ({ payload, type }: { payload: any; type: string }) => ({\n      payload,\n      type,\n    }),\n  }\n}\n\n// BigInt Serialization Middleware\n// https://redux-toolkit.js.org/api/serializabilityMiddleware\nconst isPlain = (val: any): boolean => {\n  const isPlainObject = (obj: object): boolean => {\n    if (obj === null) return false\n    const proto = Object.getPrototypeOf(obj)\n    return proto !== null && Object.getPrototypeOf(proto) === null\n  }\n  return (\n    typeof val === 'undefined' ||\n    val === null ||\n    typeof val === 'string' ||\n    typeof val === 'boolean' ||\n    typeof val === 'number' ||\n    Array.isArray(val) ||\n    isPlainObject(val) ||\n    typeof val === 'bigint' ||\n    val instanceof PublicKey ||\n    val instanceof BN ||\n    val instanceof Buffer\n  )\n}\nBigInt.prototype.toJSON = function () {\n  return this.toString() // https://github.com/GoogleChromeLabs/jsbi/issues/30\n}\nexport const bigintSerializationMiddleware = {\n  serializableCheck: {\n    isSerializable: isPlain,\n  },\n}\n","import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'\nimport { account, MintData } from '@senswap/sen-js'\n\n/**\n * Interface & Utility\n */\n\nexport type MintsState = Record<string, MintData>\n\n/**\n * Store constructor\n */\n\nconst NAME = 'mints'\nconst initialState: MintsState = {}\n\n/**\n * Actions\n */\n\nexport const getMint = createAsyncThunk<\n  MintsState,\n  { address: string; force?: boolean },\n  { state: any }\n>(`${NAME}/getMint`, async ({ address, force = false }, { getState }) => {\n  if (!account.isAddress(address)) throw new Error('Invalid mint address')\n  if (!force) {\n    const {\n      accounts: { [address]: data },\n    } = getState()\n    if (data) return { [address]: data }\n  }\n  const { splt } = window.sentre\n  const raw = await splt.getMintData(address)\n  return { [address]: raw }\n})\n\nexport const upsetMint = createAsyncThunk<\n  MintsState,\n  { address: string; data: MintData },\n  { state: any }\n>(`${NAME}/upsetMint`, async ({ address, data }) => {\n  if (!account.isAddress(address)) throw new Error('Invalid address')\n  if (!data) throw new Error('Data is empty')\n  return { [address]: data }\n})\n\nexport const deleteMint = createAsyncThunk(\n  `${NAME}/deleteMint`,\n  async ({ address }: { address: string }) => {\n    if (!account.isAddress(address)) throw new Error('Invalid address')\n    return { address }\n  },\n)\n\n/**\n * Usual procedure\n */\n\nconst slice = createSlice({\n  name: NAME,\n  initialState,\n  reducers: {},\n  extraReducers: (builder) =>\n    void builder\n      .addCase(\n        getMint.fulfilled,\n        (state, { payload }) => void Object.assign(state, payload),\n      )\n      .addCase(\n        upsetMint.fulfilled,\n        (state, { payload }) => void Object.assign(state, payload),\n      )\n      .addCase(\n        deleteMint.fulfilled,\n        (state, { payload }) => void delete state[payload.address],\n      ),\n})\n\nexport default slice.reducer\n","import { Transaction } from '@solana/web3.js'\nimport {\n  WalletInterface,\n  Provider,\n  Signature,\n  SignedMessage,\n} from '@senswap/sen-js'\n\nimport storage from 'shared/storage'\n\nclass BaseWallet implements WalletInterface {\n  readonly walletType: string\n\n  constructor(walletType: string) {\n    this.walletType = walletType\n    storage.set('WalletType', this.walletType)\n  }\n\n  getProvider = async (): Promise<Provider> => {\n    throw new Error('Wallet is not connected')\n  }\n\n  getAddress = async (): Promise<string> => {\n    throw new Error('Wallet is not connected')\n  }\n\n  signTransaction = async (transaction: Transaction): Promise<Transaction> => {\n    const { signature, publicKey } = await this.rawSignTransaction(transaction)\n    transaction.addSignature(publicKey, signature)\n    return transaction\n  }\n\n  rawSignTransaction = async (transaction: Transaction): Promise<Signature> => {\n    throw new Error('Wallet is not connected')\n  }\n\n  signMessage = async (message: string): Promise<SignedMessage> => {\n    throw new Error('Wallet is not connected')\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ): Promise<boolean> => {\n    throw new Error('Wallet is not connected')\n  }\n\n  disconnect = async (): Promise<void> => {\n    storage.clear('WalletType')\n    const provider = await this.getProvider()\n    provider.disconnect()\n  }\n}\n\nexport default BaseWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Signature, SignedMessage } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\n\nclass CloverWallet extends BaseWallet {\n  constructor() {\n    super('Clover')\n  }\n\n  getProvider = async () => {\n    const { clover_solana } = window\n    if (!clover_solana?.isCloverWallet)\n      throw new Error('Wallet is not connected')\n    return clover_solana\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    const address = await provider.getAccount()\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transaction.feePayer = publicKey\n    const { signature } = await provider.signTransaction(transaction)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.signMessage(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default CloverWallet\n","import { Transaction } from '@solana/web3.js'\nimport { account, Signature, SignedMessage } from '@senswap/sen-js'\nimport { decode } from 'bs58'\n\nimport BaseWallet from './baseWallet'\n\nclass Coin98Wallet extends BaseWallet {\n  constructor() {\n    super('Coin98')\n  }\n\n  getProvider = async () => {\n    const { sol } = window?.coin98 || {}\n    if (!sol) throw new Error('Wallet is not connected')\n    return sol\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    const [address] = (await provider.request({ method: 'sol_accounts' })) || []\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transaction.feePayer = publicKey\n    const { signature: sig } = await provider.request({\n      method: 'sol_sign',\n      params: [transaction],\n    })\n    const signature = decode(sig)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const data = await provider.request({\n      method: 'sol_sign',\n      params: [message],\n    })\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const valid = await account.verifySignature(address, signature, message)\n    return valid as boolean\n  }\n}\n\nexport default Coin98Wallet\n","import { Transaction } from '@solana/web3.js'\nimport { Provider } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\n\nexport const GUEST_ADDRESS = 'GuestAccount11111111111111111111111111111111'\n\ntype ExpanedProvider = Provider & { address: string }\n\nclass GuestWallet extends BaseWallet {\n  constructor(callback: () => void = () => {}) {\n    super('Guest')\n\n    this._callback = callback\n  }\n\n  private _callback = () => {}\n  private _error = () => {\n    throw new Error(\n      'You are in the Guest Mode. Please connect your personal wallet to proceed the action.',\n    )\n  }\n\n  getProvider = async (): Promise<ExpanedProvider> => {\n    const provider = {\n      address: GUEST_ADDRESS,\n      disconnect: () => {},\n    }\n    return provider\n  }\n\n  getAddress = async () => {\n    const { address } = await this.getProvider()\n    return address\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    await this._callback()\n    return this._error()\n  }\n\n  signMessage = async (message: string) => {\n    await this._callback()\n    return this._error()\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    await this._callback()\n    return this._error()\n  }\n}\n\nexport default GuestWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Signature, SignedMessage } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\n\nclass PhantomWallet extends BaseWallet {\n  constructor() {\n    super('Phantom')\n  }\n\n  getProvider = async () => {\n    const { solana } = window\n    if (!solana?.isPhantom) throw new Error('Wallet is not connected')\n    if (solana.isConnected) return solana\n    return await new Promise((resolve) => {\n      solana.on('connect', () => resolve(solana))\n      return solana.connect()\n    })\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    const address = provider.publicKey.toString()\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transaction.feePayer = publicKey\n    const { signature } = await provider.signTransaction(transaction)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.signMessage(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default PhantomWallet\n","const KEY = 'sentre'\nconst driver = window.sessionStorage\n\nconst convert = (value: string | null) => {\n  try {\n    if (!value) return null\n    return JSON.parse(value)\n  } catch (e) {\n    return false\n  }\n}\n\nconst session = {\n  set: (key: string, value: any) => {\n    let data = convert(driver.getItem(KEY))\n    if (!data || typeof data !== 'object') data = {}\n    data[key] = value\n    driver.setItem(KEY, JSON.stringify(data))\n  },\n\n  get: (key: string) => {\n    let data = convert(driver.getItem(KEY))\n    if (!data || typeof data !== 'object') return null\n    return data[key]\n  },\n\n  clear: (key: string) => {\n    session.set(key, null)\n  },\n}\n\nexport default session\n","import { Transaction, Keypair } from '@solana/web3.js'\nimport { sign, hash } from 'tweetnacl'\nimport { account, Provider, Signature } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\nimport session from 'shared/session'\nimport storage from 'shared/storage'\n\ntype ExpanedProvider = Provider & { keypair: Keypair }\n\nclass SecretKeyWallet extends BaseWallet {\n  constructor(secretKey: string, password?: string) {\n    super('SecretKey')\n\n    SecretKeyWallet.setSecretKey(secretKey, password)\n  }\n\n  static xor = (\n    a: Buffer | Uint8Array,\n    b: Buffer | Uint8Array,\n  ): Buffer | Uint8Array => {\n    if (a.length !== b.length)\n      throw new Error('Cannot XOR two different-length buffers')\n    const r = Buffer.alloc(a.length)\n    for (let i = 0; i < r.length; i++) r[i] = a[i] ^ b[i]\n    return r\n  }\n\n  static getPassword = (): string => {\n    let pwd = session.get('Password')\n    if (!pwd) pwd = window.prompt('Input the password:')\n    if (!pwd) throw new Error('User rejects to sign the transaction')\n    session.set('Password', pwd)\n    return pwd\n  }\n\n  static setSecretKey = (secretKeyString: string, pwd?: string): void => {\n    const { secretKey } = account.fromSecretKey(secretKeyString) || {}\n    if (!secretKey) throw new Error('Invalid secret key')\n    pwd = pwd || SecretKeyWallet.getPassword()\n    const seed = hash(Buffer.from(pwd))\n    const confusedSecretKey = SecretKeyWallet.xor(seed, secretKey)\n    storage.set('SecretKey', confusedSecretKey.toString('hex'))\n  }\n\n  static getSecretKey = (pwd?: string): string => {\n    pwd = pwd || SecretKeyWallet.getPassword()\n    const seed = hash(Buffer.from(pwd))\n    const confusedSecretKey = storage.get('SecretKey')\n    if (!confusedSecretKey) throw new Error('Invalid secret key')\n    const secretKey = SecretKeyWallet.xor(\n      seed,\n      Buffer.from(confusedSecretKey, 'hex'),\n    )\n    return secretKey.toString('hex')\n  }\n\n  getProvider = async (): Promise<ExpanedProvider> => {\n    const secretKey = SecretKeyWallet.getSecretKey()\n    const keypair = account.fromSecretKey(secretKey)\n    if (!keypair) throw new Error('Cannot get the keystore-based provider')\n    const provider = {\n      keypair,\n      disconnect: () => session.clear('SecretKey'),\n    }\n    return provider\n  }\n\n  getAddress = async () => {\n    const { keypair } = await this.getProvider()\n    return keypair.publicKey.toBase58()\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const confirmed = window.confirm('Please confirm to sign the transaction!')\n    if (!confirmed) throw new Error('User rejects to sign the transaction')\n    const { keypair } = await this.getProvider()\n    const signData = transaction.serializeMessage()\n    const publicKey = keypair.publicKey\n    const signature = sign.detached(signData, keypair.secretKey)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const confirmed = window.confirm(\n      `Please confirm to sign the message! Message: ${message}`,\n    )\n    if (!confirmed) throw new Error('User rejects to sign the message')\n    const { keypair } = await this.getProvider()\n    const secretKey = Buffer.from(keypair.secretKey).toString('hex')\n    const data = account.signMessage(message, secretKey)\n    return { ...data }\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const valid = account.verifySignature(address, signature, message)\n    return valid as boolean\n  }\n}\n\nexport default SecretKeyWallet\n","import { Transaction, PublicKey } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Signature } from '@senswap/sen-js'\nimport { decode, encode } from 'bs58'\n\nimport BaseWallet from './baseWallet'\n\nclass SlopeWallet extends BaseWallet {\n  private provider: any\n  constructor() {\n    super('Slope')\n    this.provider = null\n  }\n\n  getProvider = async () => {\n    const { Slope } = window || {}\n    if (!Slope) throw new Error('Cannot connect to Slope')\n    if (this.provider) return this.provider\n    this.provider = new Slope()\n    await this.provider.connect()\n    return this.provider\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    const { data } = await provider.connect()\n    if (!data.publicKey) throw new Error('Wallet is not connected')\n    return data.publicKey\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const message = encode(transaction.serializeMessage())\n    const { msg, data } = await provider.signTransaction(message)\n\n    if (!data.publicKey) throw new Error(msg)\n    const publicKey = new PublicKey(data.publicKey)\n    const signature = decode(data.signature)\n\n    return { publicKey, signature } as Signature\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    const slopeAddress = address || (await this.getAddress())\n    const publicKey = account.fromAddress(slopeAddress)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SlopeWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Signature, SignedMessage } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\n\nclass SolflareExtWallet extends BaseWallet {\n  constructor() {\n    super('SolflareExtension')\n  }\n\n  getProvider = async () => {\n    const { solflare } = window\n    if (!solflare.isSolflare) throw new Error('Wallet is not connected')\n    if (solflare.isConnected) return solflare\n    return await new Promise((resolve) => {\n      solflare.on('connect', () => resolve(solflare))\n      return solflare.connect()\n    })\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    const address = provider.publicKey.toString()\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transaction.feePayer = publicKey\n    const { signature } = await provider.signTransaction(transaction)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.signMessage(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SolflareExtWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Provider, Signature, SignedMessage } from '@senswap/sen-js'\nimport WalletAdapter from '@project-serum/sol-wallet-adapter'\n\nimport BaseWallet from './baseWallet'\nimport configs from 'os/configs'\n\nconst PROVIDER_URL = 'https://solflare.com/provider'\n\nclass SolflareWebWallet extends BaseWallet {\n  private provider: WalletAdapter & Provider\n\n  constructor() {\n    super('SolflareWeb')\n\n    const {\n      sol: { node },\n    } = configs\n    this.provider = new WalletAdapter(PROVIDER_URL, node)\n  }\n\n  getProvider = async () => {\n    if (!this.provider.connected) await this.provider.connect()\n    return this.provider\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    if (!provider.publicKey) throw new Error('Cannot connect to Solflare')\n    return provider.publicKey.toBase58()\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transaction.feePayer = publicKey\n    const { signature } = await provider.signTransaction(transaction)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.sign(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SolflareWebWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Provider, Signature, SignedMessage } from '@senswap/sen-js'\nimport WalletAdapter from '@project-serum/sol-wallet-adapter'\n\nimport BaseWallet from './baseWallet'\nimport configs from 'os/configs'\n\nconst PROVIDER_URL = 'https://www.sollet.io'\n\nclass SolletWallet extends BaseWallet {\n  private provider: WalletAdapter & Provider\n\n  constructor() {\n    super('SolletWeb')\n\n    const {\n      sol: { node },\n    } = configs\n    this.provider = new WalletAdapter(PROVIDER_URL, node)\n  }\n\n  getProvider = async () => {\n    if (!this.provider.connected) await this.provider.connect()\n    return this.provider\n  }\n\n  getAddress = async () => {\n    const provider = await this.getProvider()\n    if (!provider.publicKey) throw new Error('Cannot connect to Sollet Web')\n    return provider.publicKey.toBase58()\n  }\n\n  rawSignTransaction = async (transaction: Transaction) => {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transaction.feePayer = publicKey\n    const { signature } = await provider.signTransaction(transaction)\n    return { publicKey, signature } as Signature\n  }\n\n  signMessage = async (message: string) => {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.sign(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  verifySignature = async (\n    signature: string,\n    message: string,\n    address?: string,\n  ) => {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SolletWallet\n","import localForage from 'localforage'\nimport { account } from '@senswap/sen-js'\nimport IPFS from './ipfs'\n\n/**\n * Persistent Database\n */\nclass PDB {\n  readonly dbName: string\n  private driver: any\n  private ipfs: IPFS\n\n  constructor(walletAddress: string) {\n    if (!account.isAddress(walletAddress)) throw new Error('Invalid address')\n    this.dbName = walletAddress\n    this.driver = [localForage.WEBSQL, localForage.LOCALSTORAGE]\n    this.ipfs = new IPFS()\n  }\n\n  /**\n   * Local\n   */\n\n  createInstance = (appId: string): LocalForage => {\n    return localForage.createInstance({\n      driver: this.driver,\n      name: this.dbName,\n      storeName: appId,\n    })\n  }\n\n  dropInstance = async (appId: string): Promise<void> => {\n    const instance = this.createInstance(appId)\n    await instance.clear()\n    return await localForage.dropInstance({\n      name: this.dbName,\n      storeName: appId,\n    })\n  }\n\n  all = async (): Promise<any> => {\n    let data: any = {}\n    const appIds = (\n      ((await this.createInstance('sentre').getItem('appIds')) as string[]) ||\n      []\n    )\n      .flat()\n      .concat(['sentre'])\n    for (const appId of appIds) {\n      data[appId] = {}\n      const instance = this.createInstance(appId)\n      await instance.iterate((value: string, key: string) => {\n        data[appId][key] = value\n      })\n    }\n    return data\n  }\n\n  /**\n   * Cloud\n   */\n\n  fetch = async (cid: string) => {\n    return await this.ipfs.get(cid)\n  }\n\n  backup = async () => {\n    const data = await this.all()\n    return await this.ipfs.set(data)\n  }\n\n  restore = async (cid: string) => {\n    // Download data\n    const data = await this.fetch(cid)\n    // Apply to storage\n    for (const appId in data) {\n      const instance = await this.createInstance(appId)\n      for (const key in data[appId]) {\n        const value = data[appId][key]\n        await instance.setItem(key, value)\n      }\n    }\n    return data\n  }\n}\n\nexport default PDB\n\n/**\n * High abtraction pdb for app\n */\nexport const createPDB = (walletArress: string, appId: string) => {\n  return account.isAddress(walletArress)\n    ? new PDB(walletArress).createInstance(appId)\n    : undefined\n}\n","import { create, isIPFS } from 'ipfs-core'\nimport { asyncWait } from 'shared/util'\n\nclass IPFS {\n  private _ipfs: any = async () => {\n    try {\n      if (!window.ipfs) window.ipfs = await create()\n      return window.ipfs\n    } catch (er) {\n      await asyncWait(500)\n      return await this._ipfs()\n    }\n  }\n\n  static isCID = (cid: string | undefined | null): boolean => {\n    try {\n      if (!cid) return false\n      return isIPFS.multihash(cid)\n    } catch (er) {\n      return false\n    }\n  }\n\n  get = async (cid: string) => {\n    if (!IPFS.isCID(cid)) throw new Error('Invalid CID')\n    const ipfs = await this._ipfs()\n    const stream = await ipfs.cat(cid)\n    let raw = ''\n    for await (const chunk of stream) raw += Buffer.from(chunk).toString()\n    const data = JSON.parse(raw)\n    return data\n  }\n\n  set = async (data: object): Promise<string> => {\n    if (!data) throw new Error('Empty data')\n    const raw = JSON.stringify(data)\n    const ipfs = await this._ipfs()\n    const { cid } = await ipfs.add(raw)\n    return cid.toString()\n  }\n}\n\nexport default IPFS\n"],"names":["SOLVARS","spltAddress","splataAddress","devnet","node","rpc","swapAddress","taxmanAddress","testnet","mainnet","DEFAULT_APP_ID","process","devApp","url","appId","name","author","email","tags","split","map","tag","trim","description","verified","development","devAppId","extra","senreg","staging","production","sol","net","register","env","devTools","appName","BigInt","prototype","toJSON","this","toString","bigintSerializationMiddleware","serializableCheck","isSerializable","val","Array","isArray","obj","proto","Object","getPrototypeOf","isPlainObject","PublicKey","BN","Buffer","NAME","getMint","createAsyncThunk","async","address","force","getState","account","Error","accounts","data","splt","window","sentre","getMintData","upsetMint","deleteMint","createSlice","initialState","reducers","extraReducers","builder","addCase","fulfilled","state","payload","assign","constructor","walletType","getProvider","getAddress","signTransaction","signature","publicKey","rawSignTransaction","transaction","addSignature","signMessage","verifySignature","message","disconnect","storage","CloverWallet","BaseWallet","super","clover_solana","isCloverWallet","provider","getAccount","feePayer","encodedMsg","TextEncoder","encode","sig","from","bufSig","nacl","toBuffer","Coin98Wallet","coin98","request","method","params","decode","GuestWallet","callback","_callback","_error","PhantomWallet","solana","isPhantom","isConnected","Promise","resolve","on","connect","KEY","driver","sessionStorage","convert","value","JSON","parse","e","session","set","key","getItem","setItem","stringify","get","clear","SecretKeyWallet","secretKey","password","getSecretKey","keypair","toBase58","confirm","signData","serializeMessage","sign","setSecretKey","xor","a","b","length","r","alloc","i","getPassword","pwd","prompt","secretKeyString","seed","hash","confusedSecretKey","SlopeWallet","Slope","msg","slopeAddress","SolflareExtWallet","solflare","isSolflare","SolflareWebWallet","connected","configs","WalletAdapter","SolletWallet","PDB","walletAddress","dbName","ipfs","createInstance","localForage","storeName","dropInstance","instance","all","appIds","flat","concat","iterate","fetch","cid","backup","restore","IPFS","_ipfs","create","er","asyncWait","isCID","stream","cat","raw","chunk","add","isIPFS"],"sourceRoot":""}