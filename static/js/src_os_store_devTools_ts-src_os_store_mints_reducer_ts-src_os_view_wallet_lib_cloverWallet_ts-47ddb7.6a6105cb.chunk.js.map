{"version":3,"file":"static/js/src_os_store_devTools_ts-src_os_store_mints_reducer_ts-src_os_view_wallet_lib_cloverWallet_ts-47ddb7.6a6105cb.chunk.js","mappings":"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","sources":["os/configs/sol.config.ts","os/configs/register.config.ts","os/configs/index.ts","os/store/devTools.ts","os/store/mints.reducer.ts","os/view/wallet/lib/baseWallet.ts","os/view/wallet/lib/cloverWallet.ts","os/view/wallet/lib/coin98Wallet.ts","os/view/wallet/lib/decorators.ts","os/view/wallet/lib/guestWallet.ts","os/view/wallet/lib/phantomWallet.ts","shared/session.ts","os/view/wallet/lib/secretkeyWallet.ts","os/view/wallet/lib/slopeWallet.ts","os/view/wallet/lib/solflareExtWallet.ts","os/view/wallet/lib/solflareWebWallet.ts","os/view/wallet/lib/solletWebWallet.ts","shared/pdb/index.ts","shared/pdb/ipfs.ts"],"sourcesContent":["import { Net, rpc } from 'shared/runtime'\n\nconst SOLVARS = {\n  spltAddress: 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',\n  splataAddress: 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n}\n\n/**\n * Contructor\n */\ntype Conf = {\n  node: string\n  swapAddress: string\n  taxmanAddress: string\n  platformFee: number\n} & typeof SOLVARS\n\nconst conf: Record<Net, Conf> = {\n  /**\n   * Development configurations\n   */\n  devnet: {\n    ...SOLVARS,\n    node: rpc,\n    swapAddress: '4erFSLP7oBFSVC1t35jdxmbfxEhYCKfoM6XdG2BLR3UF',\n    taxmanAddress: '8UaZw2jDhJzv5V53569JbCd3bD4BnyCfBH3sjwgajGS9',\n    platformFee: 5000,\n  },\n\n  /**\n   * Staging configurations\n   */\n  testnet: {\n    ...SOLVARS,\n    node: rpc,\n    swapAddress: '4erFSLP7oBFSVC1t35jdxmbfxEhYCKfoM6XdG2BLR3UF',\n    taxmanAddress: '8UaZw2jDhJzv5V53569JbCd3bD4BnyCfBH3sjwgajGS9',\n    platformFee: 5000,\n  },\n\n  /**\n   * Production configurations\n   */\n  mainnet: {\n    ...SOLVARS,\n    node: rpc,\n    swapAddress: 'SSW7ooZ1EbEognq5GosbygA3uWW1Hq1NsFq6TsftCFV',\n    taxmanAddress: '9doo2HZQEmh2NgfT3Yx12M89aoBheycYqH1eaR5gKb3e',\n    platformFee: 5000,\n  },\n}\n\n/**\n * Module exports\n */\nexport default conf\n","import { Env } from 'shared/runtime'\n\nif (\n  typeof process.env.REACT_APP_ID !== 'string' ||\n  typeof process.env.REACT_APP_NAME !== 'string' ||\n  typeof process.env.REACT_APP_URL !== 'string'\n)\n  throw new Error(\n    'Please add REACT_APP_ID, REACT_APP_NAME, REACT_APP_URL in .env.local!',\n  )\n\n/**\n * Contructor\n */\n\ntype Conf = {\n  devAppId: string\n  extra: SenReg\n  senreg: string\n}\n\nconst DEFAULT_APP_ID = process.env.REACT_APP_ID\nconst devApp = {\n  [DEFAULT_APP_ID]: {\n    url: process.env.REACT_APP_URL,\n    appId: DEFAULT_APP_ID,\n    name: process.env.REACT_APP_NAME,\n    author: {\n      name: process.env.REACT_APP_AUTHOR_NAME || '',\n      email: process.env.REACT_APP_AUTHOR_EMAIL || '',\n    },\n    tags: (process.env.REACT_APP_TAGS || '')\n      .split(',')\n      .map((tag) => tag.trim()),\n    description: process.env.REACT_APP_DESCRIPTION || '',\n    verified: false,\n  },\n}\n\nconst conf: Record<Env, Conf> = {\n  /**\n   * Development configurations\n   */\n  development: {\n    devAppId: DEFAULT_APP_ID,\n    extra: devApp,\n    senreg: 'https://descartesnetwork.github.io/senreg/register.json',\n  },\n\n  /**\n   * Staging configurations\n   */\n  staging: {\n    devAppId: DEFAULT_APP_ID,\n    extra: devApp,\n    senreg: 'https://descartesnetwork.github.io/senreg/register.json',\n  },\n\n  /**\n   * Production configurations\n   */\n  production: {\n    devAppId: DEFAULT_APP_ID,\n    extra: {},\n    senreg: 'https://descartesnetwork.github.io/senreg/register.json',\n  },\n}\n\n/**\n * Module exports\n */\nexport default conf\n","import { net, env } from 'shared/runtime'\nimport sol from './sol.config'\nimport register from './register.config'\n\nconst configs = {\n  sol: sol[net],\n  register: register[env],\n}\n\n/**\n * Module exports\n */\nexport default configs\n","import { PublicKey } from '@solana/web3.js'\nimport BN from 'bn.js'\n\n// Bugfix performance\n// https://github.com/zalmoxisus/redux-devtools-extension/blob/master/docs/Troubleshooting.md#excessive-use-of-memory-and-cpu\nexport const devTools = (appName: string): any => {\n  if (process.env.REACT_APP_ENV !== 'development') return false\n  return {\n    name: appName,\n    actionSanitizer: ({ payload, type }: { payload: any; type: string }) => ({\n      payload,\n      type,\n    }),\n  }\n}\n\n// BigInt Serialization Middleware\n// https://redux-toolkit.js.org/api/serializabilityMiddleware\nconst isPlain = (val: any): boolean => {\n  const isPlainObject = (obj: object): boolean => {\n    if (obj === null) return false\n    const proto = Object.getPrototypeOf(obj)\n    return proto !== null && Object.getPrototypeOf(proto) === null\n  }\n  return (\n    typeof val === 'undefined' ||\n    val === null ||\n    typeof val === 'string' ||\n    typeof val === 'boolean' ||\n    typeof val === 'number' ||\n    Array.isArray(val) ||\n    isPlainObject(val) ||\n    typeof val === 'bigint' ||\n    val instanceof PublicKey ||\n    val instanceof BN ||\n    Buffer.isBuffer(val)\n  )\n}\nBigInt.prototype.toJSON = function () {\n  return this.toString() // https://github.com/GoogleChromeLabs/jsbi/issues/30\n}\nexport const bigintSerializationMiddleware = {\n  serializableCheck: {\n    isSerializable: isPlain,\n  },\n}\n","import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'\nimport { account, MintData } from '@senswap/sen-js'\n\n/**\n * Interface & Utility\n */\n\nexport type MintsState = Record<string, MintData>\n\n/**\n * Store constructor\n */\n\nconst NAME = 'mints'\nconst initialState: MintsState = {}\n\n/**\n * Actions\n */\n\nexport const getMint = createAsyncThunk<\n  MintsState,\n  { address: string; force?: boolean },\n  { state: any }\n>(`${NAME}/getMint`, async ({ address, force = false }, { getState }) => {\n  if (!account.isAddress(address)) throw new Error('Invalid mint address')\n  if (!force) {\n    const {\n      accounts: { [address]: data },\n    } = getState()\n    if (data) return { [address]: data }\n  }\n  const { splt } = window.sentre\n  const raw = await splt.getMintData(address)\n  return { [address]: raw }\n})\n\nexport const upsetMint = createAsyncThunk<\n  MintsState,\n  { address: string; data: MintData },\n  { state: any }\n>(`${NAME}/upsetMint`, async ({ address, data }) => {\n  if (!account.isAddress(address)) throw new Error('Invalid address')\n  if (!data) throw new Error('Data is empty')\n  return { [address]: data }\n})\n\nexport const deleteMint = createAsyncThunk(\n  `${NAME}/deleteMint`,\n  async ({ address }: { address: string }) => {\n    if (!account.isAddress(address)) throw new Error('Invalid address')\n    return { address }\n  },\n)\n\n/**\n * Usual procedure\n */\n\nconst slice = createSlice({\n  name: NAME,\n  initialState,\n  reducers: {},\n  extraReducers: (builder) =>\n    void builder\n      .addCase(\n        getMint.fulfilled,\n        (state, { payload }) => void Object.assign(state, payload),\n      )\n      .addCase(\n        upsetMint.fulfilled,\n        (state, { payload }) => void Object.assign(state, payload),\n      )\n      .addCase(\n        deleteMint.fulfilled,\n        (state, { payload }) => void delete state[payload.address],\n      ),\n})\n\nexport default slice.reducer\n","import { Transaction } from '@solana/web3.js'\nimport { Provider, WalletInterface, SignedMessage } from '@senswap/sen-js'\n\nimport storage from 'shared/storage'\n\nclass BaseWallet implements WalletInterface {\n  readonly walletType: string\n\n  constructor(walletType: string) {\n    this.walletType = walletType\n    storage.set('WalletType', this.walletType)\n  }\n\n  async getProvider(): Promise<Provider> {\n    throw new Error('Wallet is not connected')\n  }\n\n  async getAddress(): Promise<string> {\n    throw new Error('Wallet is not connected')\n  }\n\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    throw new Error('Wallet is not connected')\n  }\n\n  async signAllTransactions(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    throw new Error('Wallet is not connected')\n  }\n\n  async signMessage(message: string): Promise<SignedMessage> {\n    throw new Error('Wallet is not connected')\n  }\n\n  async verifySignature(\n    signature: string,\n    message: string,\n    address?: string,\n  ): Promise<boolean> {\n    throw new Error('Wallet is not connected')\n  }\n\n  async disconnect(): Promise<void> {\n    storage.clear('WalletType')\n    const provider = await this.getProvider()\n    provider.disconnect()\n  }\n}\n\nexport default BaseWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, SignedMessage } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\nimport { collectFee, collectFees } from './decorators'\n\nclass CloverWallet extends BaseWallet {\n  constructor() {\n    super('Clover')\n  }\n\n  async getProvider() {\n    const { clover_solana } = window\n    if (!clover_solana?.isCloverWallet)\n      throw new Error('Wallet is not connected')\n    return clover_solana\n  }\n\n  async getAddress(): Promise<string> {\n    const provider = await this.getProvider()\n    const address = await provider.getAccount()\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  @collectFee\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    return await provider.signTransaction(transaction)\n  }\n\n  @collectFees\n  async signAllTransactions(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    return await provider.signAllTransactions(transactions)\n  }\n\n  async signMessage(message: string) {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.signMessage(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  async verifySignature(signature: string, message: string, address?: string) {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default CloverWallet\n","import { Transaction } from '@solana/web3.js'\nimport { account, SignedMessage } from '@senswap/sen-js'\nimport { decode } from 'bs58'\n\nimport BaseWallet from './baseWallet'\nimport { collectFee, collectFees } from './decorators'\n\nclass Coin98Wallet extends BaseWallet {\n  constructor() {\n    super('Coin98')\n  }\n\n  async getProvider() {\n    const { sol } = window?.coin98 || {}\n    if (!sol) throw new Error('Wallet is not connected')\n    return sol\n  }\n\n  async getAddress(): Promise<string> {\n    const provider = await this.getProvider()\n    const [address] = (await provider.request({ method: 'sol_accounts' })) || []\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  @collectFee\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    const { signature: sig } = await provider.request({\n      method: 'sol_sign',\n      params: [transaction],\n    })\n    const signature = decode(sig)\n    transaction.addSignature(publicKey, signature)\n    return transaction\n  }\n\n  @collectFees\n  async signAllTransactions(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    const { signatures } = await provider.request({\n      method: 'sol_signAllTransactions',\n      params: [transactions],\n    })\n    signatures.forEach((sig: string, i: number) => {\n      const signature = decode(sig)\n      transactions[i].addSignature(publicKey, signature)\n    })\n    return transactions\n  }\n\n  async signMessage(message: string) {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const data = await provider.request({\n      method: 'sol_sign',\n      params: [message],\n    })\n    return data as SignedMessage\n  }\n\n  async verifySignature(signature: string, message: string, address?: string) {\n    address = address || (await this.getAddress())\n    const valid = await account.verifySignature(address, signature, message)\n    return valid as boolean\n  }\n}\n\nexport default Coin98Wallet\n","import { Transaction, SystemProgram, PublicKey } from '@solana/web3.js'\n\nimport configs from 'os/configs'\n\nconst {\n  sol: { taxmanAddress, platformFee },\n} = configs\n\nexport const collectFee = (\n  target: any,\n  memberName: string,\n  descriptor: PropertyDescriptor,\n) => {\n  const original = descriptor.value\n  descriptor.value = async function (tx: Transaction) {\n    const ix = SystemProgram.transfer({\n      fromPubkey: tx.feePayer || (await target.getAddress()),\n      toPubkey: new PublicKey(taxmanAddress),\n      lamports: platformFee,\n    })\n    tx.add(ix)\n    return original.call(target, tx)\n  }\n}\n\nexport const collectFees = (\n  target: any,\n  memberName: string,\n  descriptor: PropertyDescriptor,\n) => {\n  const original = descriptor.value\n  descriptor.value = async (txs: Transaction[]) => {\n    for (const tx of txs) {\n      const ix = SystemProgram.transfer({\n        fromPubkey: tx.feePayer || (await target.getAddress()),\n        toPubkey: new PublicKey(taxmanAddress),\n        lamports: platformFee,\n      })\n      tx.add(ix)\n    }\n    return original.call(target, txs)\n  }\n}\n","import { Transaction } from '@solana/web3.js'\nimport { Provider } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\n\nexport const GUEST_ADDRESS = 'GuestAccount11111111111111111111111111111111'\n\ntype ExpanedProvider = Provider & { address: string }\n\nclass GuestWallet extends BaseWallet {\n  constructor(callback: () => void = () => {}) {\n    super('Guest')\n\n    this._callback = callback\n  }\n\n  private _callback = () => {}\n  private _error = () => {\n    throw new Error(\n      'You are in the Guest Mode. Please connect your personal wallet to proceed the action.',\n    )\n  }\n\n  async getProvider(): Promise<ExpanedProvider> {\n    const provider = {\n      address: GUEST_ADDRESS,\n      disconnect: () => {},\n    }\n    return provider\n  }\n\n  async getAddress(): Promise<string> {\n    const { address } = await this.getProvider()\n    return address\n  }\n\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    await this._callback()\n    return this._error()\n  }\n\n  async signAllTransaction(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    await this._callback()\n    return this._error()\n  }\n\n  async signMessage(message: string) {\n    await this._callback()\n    return this._error()\n  }\n\n  async verifySignature(signature: string, message: string, address?: string) {\n    await this._callback()\n    return this._error()\n  }\n}\n\nexport default GuestWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, SignedMessage } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\nimport { collectFee, collectFees } from './decorators'\n\nclass PhantomWallet extends BaseWallet {\n  constructor() {\n    super('Phantom')\n  }\n\n  async getProvider() {\n    const { solana } = window\n    if (!solana?.isPhantom) throw new Error('Wallet is not connected')\n    if (solana.isConnected) return solana\n    return await new Promise((resolve) => {\n      solana.on('connect', () => resolve(solana))\n      return solana.connect()\n    })\n  }\n\n  async getAddress(): Promise<string> {\n    const provider = await this.getProvider()\n    const address = provider.publicKey.toString()\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  @collectFee\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    return await provider.signTransaction(transaction)\n  }\n\n  @collectFees\n  async signAllTransactions(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    return await provider.signAllTransactions(transactions)\n  }\n\n  async signMessage(message: string) {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.signMessage(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  async verifySignature(signature: string, message: string, address?: string) {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default PhantomWallet\n","const KEY = 'sentre'\nconst driver = window.sessionStorage\n\nconst convert = (value: string | null) => {\n  try {\n    if (!value) return null\n    return JSON.parse(value)\n  } catch (e) {\n    return false\n  }\n}\n\nconst session = {\n  set: (key: string, value: any) => {\n    let data = convert(driver.getItem(KEY))\n    if (!data || typeof data !== 'object') data = {}\n    data[key] = value\n    driver.setItem(KEY, JSON.stringify(data))\n  },\n\n  get: (key: string) => {\n    let data = convert(driver.getItem(KEY))\n    if (!data || typeof data !== 'object') return null\n    return data[key]\n  },\n\n  clear: (key: string) => {\n    session.set(key, null)\n  },\n}\n\nexport default session\n","import { Transaction, Keypair } from '@solana/web3.js'\nimport { sign, hash } from 'tweetnacl'\nimport { account, Provider } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\nimport session from 'shared/session'\nimport storage from 'shared/storage'\nimport { collectFee, collectFees } from './decorators'\n\ntype ExpanedProvider = Provider & { keypair: Keypair }\n\nclass SecretKeyWallet extends BaseWallet {\n  constructor(secretKey: string, password?: string) {\n    super('SecretKey')\n\n    SecretKeyWallet.setSecretKey(secretKey, password)\n  }\n\n  static xor(\n    a: Buffer | Uint8Array,\n    b: Buffer | Uint8Array,\n  ): Buffer | Uint8Array {\n    if (a.length !== b.length)\n      throw new Error('Cannot XOR two different-length buffers')\n    const r = Buffer.alloc(a.length)\n    for (let i = 0; i < r.length; i++) r[i] = a[i] ^ b[i]\n    return r\n  }\n\n  static getPassword(): string {\n    let pwd = session.get('Password')\n    if (!pwd) pwd = window.prompt('Input the password:')\n    if (!pwd) throw new Error('User rejects to sign the transaction')\n    session.set('Password', pwd)\n    return pwd\n  }\n\n  static setSecretKey(secretKeyString: string, pwd?: string): void {\n    const { secretKey } = account.fromSecretKey(secretKeyString) || {}\n    if (!secretKey) throw new Error('Invalid secret key')\n    pwd = pwd || SecretKeyWallet.getPassword()\n    const seed = hash(Buffer.from(pwd))\n    const confusedSecretKey = SecretKeyWallet.xor(seed, secretKey)\n    storage.set('SecretKey', confusedSecretKey.toString('hex'))\n  }\n\n  static getSecretKey(pwd?: string): string {\n    pwd = pwd || SecretKeyWallet.getPassword()\n    const seed = hash(Buffer.from(pwd))\n    const confusedSecretKey = storage.get('SecretKey')\n    if (!confusedSecretKey) throw new Error('Invalid secret key')\n    const secretKey = SecretKeyWallet.xor(\n      seed,\n      Buffer.from(confusedSecretKey, 'hex'),\n    )\n    return secretKey.toString('hex')\n  }\n\n  async getProvider(): Promise<ExpanedProvider> {\n    const secretKey = SecretKeyWallet.getSecretKey()\n    const keypair = account.fromSecretKey(secretKey)\n    if (!keypair) throw new Error('Cannot get the keystore-based provider')\n    const provider = {\n      keypair,\n      disconnect: () => session.clear('SecretKey'),\n    }\n    return provider\n  }\n\n  async getAddress(): Promise<string> {\n    const { keypair } = await this.getProvider()\n    return keypair.publicKey.toBase58()\n  }\n\n  @collectFee\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    const confirmed = window.confirm('Please confirm to sign the transaction!')\n    if (!confirmed) throw new Error('User rejects to sign the transaction')\n    const { keypair } = await this.getProvider()\n    const signData = transaction.serializeMessage()\n    const publicKey = keypair.publicKey\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    const signature = sign.detached(signData, keypair.secretKey)\n    transaction.addSignature(publicKey, Buffer.from(signature))\n    return transaction\n  }\n\n  @collectFees\n  async signAllTransactions(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    const confirmed = window.confirm('Please confirm to sign the transactions!')\n    if (!confirmed) throw new Error('User rejects to sign the transactions')\n    const { keypair } = await this.getProvider()\n    const txs: Transaction[] = []\n    for (const transaction of transactions) {\n      const signData = transaction.serializeMessage()\n      const publicKey = keypair.publicKey\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n      const signature = sign.detached(signData, keypair.secretKey)\n      transaction.addSignature(publicKey, Buffer.from(signature))\n      txs.push(transaction)\n    }\n    return txs\n  }\n\n  async signMessage(message: string) {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const confirmed = window.confirm(\n      `Please confirm to sign the message! Message: ${message}`,\n    )\n    if (!confirmed) throw new Error('User rejects to sign the message')\n    const { keypair } = await this.getProvider()\n    const secretKey = Buffer.from(keypair.secretKey).toString('hex')\n    const data = account.signMessage(message, secretKey)\n    return { ...data }\n  }\n\n  async verifySignature(signature: string, message: string, address?: string) {\n    address = address || (await this.getAddress())\n    const valid = account.verifySignature(address, signature, message)\n    return valid as boolean\n  }\n}\n\nexport default SecretKeyWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account } from '@senswap/sen-js'\nimport { decode, encode } from 'bs58'\n\nimport BaseWallet from './baseWallet'\nimport { collectFee, collectFees } from './decorators'\n\nclass SlopeWallet extends BaseWallet {\n  private provider: any\n  constructor() {\n    super('Slope')\n    this.provider = null\n  }\n\n  async getProvider() {\n    const { Slope } = window || {}\n    if (!Slope) throw new Error('Cannot connect to Slope')\n    if (this.provider) return this.provider\n    this.provider = new Slope()\n    await this.provider.connect()\n    return this.provider\n  }\n\n  async getAddress(): Promise<string> {\n    const provider = await this.getProvider()\n    const { data } = await provider.connect()\n    if (!data.publicKey) throw new Error('Wallet is not connected')\n    return data.publicKey\n  }\n\n  @collectFee\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    const message = encode(transaction.serializeMessage())\n    const { msg, data } = await provider.signTransaction(message)\n    if (!data.publicKey || !data.signature) throw new Error(msg)\n    const signature = decode(data.signature)\n    transaction.addSignature(publicKey, signature)\n    return transaction\n  }\n\n  @collectFees\n  async signAllTransactions(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    const messages = transactions.map((transaction) =>\n      encode(transaction.serializeMessage()),\n    )\n    const { msg, data } = await provider.signAllTransactions(messages)\n    if (!data.publicKey || data.signatures?.length !== transactions.length)\n      throw new Error(msg)\n    data.signatures.forEach((sig: string, i: number) => {\n      const signature = decode(sig)\n      transactions[i].addSignature(publicKey, signature)\n    })\n    return transactions\n  }\n\n  async verifySignature(signature: string, message: string, address?: string) {\n    const slopeAddress = address || (await this.getAddress())\n    const publicKey = account.fromAddress(slopeAddress)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SlopeWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, SignedMessage } from '@senswap/sen-js'\n\nimport BaseWallet from './baseWallet'\nimport { collectFee, collectFees } from './decorators'\n\nclass SolflareExtWallet extends BaseWallet {\n  constructor() {\n    super('SolflareExtension')\n  }\n\n  async getProvider() {\n    const { solflare } = window\n    if (!solflare.isSolflare) throw new Error('Wallet is not connected')\n    if (solflare.isConnected) return solflare\n    return await new Promise((resolve) => {\n      solflare.on('connect', () => resolve(solflare))\n      return solflare.connect()\n    })\n  }\n\n  async getAddress(): Promise<string> {\n    const provider = await this.getProvider()\n    const address = provider.publicKey.toString()\n    if (!account.isAddress(address))\n      throw new Error('There is no Solana account')\n    return address\n  }\n\n  @collectFee\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    return await provider.signTransaction(transaction)\n  }\n\n  @collectFees\n  async signAllTransactions(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    return await provider.signAllTransactions(transactions)\n  }\n\n  async signMessage(message: string) {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.signMessage(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  async verifySignature(signature: string, message: string, address?: string) {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SolflareExtWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Provider, SignedMessage } from '@senswap/sen-js'\nimport WalletAdapter from '@project-serum/sol-wallet-adapter'\n\nimport BaseWallet from './baseWallet'\nimport configs from 'os/configs'\nimport { collectFee, collectFees } from './decorators'\n\nconst {\n  sol: { node },\n} = configs\nconst PROVIDER_URL = 'https://solflare.com/provider'\nconst PROVIDER: WalletAdapter & Provider = new WalletAdapter(PROVIDER_URL, node)\n\nclass SolflareWebWallet extends BaseWallet {\n  constructor() {\n    super('SolflareWeb')\n  }\n\n  async getProvider() {\n    if (!PROVIDER.connected) await PROVIDER.connect()\n    return PROVIDER\n  }\n\n  async getAddress() {\n    const provider = await this.getProvider()\n    if (!provider.publicKey) throw new Error('Cannot connect to Solflare')\n    return provider.publicKey.toBase58()\n  }\n\n  @collectFee\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    return await provider.signTransaction(transaction)\n  }\n\n  @collectFees\n  async signAllTransactions(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    return await provider.signAllTransactions(transactions)\n  }\n\n  async signMessage(message: string) {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.sign(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  async verifySignature(signature: string, message: string, address?: string) {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SolflareWebWallet\n","import { Transaction } from '@solana/web3.js'\nimport * as nacl from 'tweetnacl'\nimport { account, Provider, SignedMessage } from '@senswap/sen-js'\nimport WalletAdapter from '@project-serum/sol-wallet-adapter'\n\nimport BaseWallet from './baseWallet'\nimport configs from 'os/configs'\nimport { collectFee, collectFees } from './decorators'\n\nconst {\n  sol: { node },\n} = configs\nconst PROVIDER_URL = 'https://www.sollet.io'\nconst PROVIDER: WalletAdapter & Provider = new WalletAdapter(PROVIDER_URL, node)\n\nclass SolletWallet extends BaseWallet {\n  constructor() {\n    super('SolletWeb')\n  }\n\n  async getProvider() {\n    if (!PROVIDER.connected) await PROVIDER.connect()\n    return PROVIDER\n  }\n\n  async getAddress(): Promise<string> {\n    const provider = await this.getProvider()\n    if (!provider.publicKey) throw new Error('Cannot connect to Sollet Web')\n    return provider.publicKey.toBase58()\n  }\n\n  @collectFee\n  async signTransaction(transaction: Transaction): Promise<Transaction> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    if (!transaction.feePayer) transaction.feePayer = publicKey\n    return await provider.signTransaction(transaction)\n  }\n\n  @collectFees\n  async signAllTransactions(\n    transactions: Transaction[],\n  ): Promise<Transaction[]> {\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const publicKey = account.fromAddress(address)\n    transactions.forEach((transaction) => {\n      if (!transaction.feePayer) transaction.feePayer = publicKey\n    })\n    return await provider.signAllTransactions(transactions)\n  }\n\n  async signMessage(message: string) {\n    if (!message) throw new Error('Message must be a non-empty string')\n    const provider = await this.getProvider()\n    const address = await this.getAddress()\n    const encodedMsg = new TextEncoder().encode(message)\n    const { signature: sig } = await provider.sign(encodedMsg, 'utf8')\n    const signature = Buffer.from(sig).toString('hex')\n    const data = { address, signature, message }\n    return data as SignedMessage\n  }\n\n  async verifySignature(signature: string, message: string, address?: string) {\n    address = address || (await this.getAddress())\n    const publicKey = account.fromAddress(address)\n    const bufSig = Buffer.from(signature, 'hex')\n    const encodedMsg = new TextEncoder().encode(message)\n    const valid = nacl.sign.detached.verify(\n      encodedMsg,\n      bufSig,\n      publicKey.toBuffer(),\n    )\n    return valid\n  }\n}\n\nexport default SolletWallet\n","import localForage from 'localforage'\nimport { account } from '@senswap/sen-js'\nimport IPFS from './ipfs'\n\n/**\n * Persistent Database\n */\nclass PDB {\n  readonly dbName: string\n  private driver: any\n  private ipfs: IPFS\n\n  constructor(walletAddress: string) {\n    if (!account.isAddress(walletAddress)) throw new Error('Invalid address')\n    this.dbName = walletAddress\n    this.driver = [localForage.WEBSQL, localForage.LOCALSTORAGE]\n    this.ipfs = new IPFS()\n  }\n\n  /**\n   * Local\n   */\n\n  createInstance = (appId: string): LocalForage => {\n    return localForage.createInstance({\n      driver: this.driver,\n      name: this.dbName,\n      storeName: appId,\n    })\n  }\n\n  dropInstance = async (appId: string): Promise<void> => {\n    const instance = this.createInstance(appId)\n    await instance.clear()\n    return await localForage.dropInstance({\n      name: this.dbName,\n      storeName: appId,\n    })\n  }\n\n  all = async (): Promise<any> => {\n    let data: any = {}\n    const appIds = (\n      ((await this.createInstance('sentre').getItem('appIds')) as string[]) ||\n      []\n    )\n      .flat()\n      .concat(['sentre'])\n    for (const appId of appIds) {\n      data[appId] = {}\n      const instance = this.createInstance(appId)\n      await instance.iterate((value: string, key: string) => {\n        data[appId][key] = value\n      })\n    }\n    return data\n  }\n\n  /**\n   * Cloud\n   */\n\n  fetch = async (cid: string) => {\n    return await this.ipfs.get(cid)\n  }\n\n  backup = async () => {\n    const data = await this.all()\n    return await this.ipfs.set(data)\n  }\n\n  restore = async (cid: string) => {\n    // Download data\n    const data = await this.fetch(cid)\n    // Apply to storage\n    for (const appId in data) {\n      const instance = await this.createInstance(appId)\n      for (const key in data[appId]) {\n        const value = data[appId][key]\n        await instance.setItem(key, value)\n      }\n    }\n    return data\n  }\n}\n\nexport default PDB\n\n/**\n * High abtraction pdb for app\n */\nexport const createPDB = (walletArress: string, appId: string) => {\n  return account.isAddress(walletArress)\n    ? new PDB(walletArress).createInstance(appId)\n    : undefined\n}\n","import { create, isIPFS } from 'ipfs-core'\nimport { asyncWait } from 'shared/util'\n\nclass IPFS {\n  private _ipfs: any = async () => {\n    try {\n      if (!window.ipfs) window.ipfs = await create()\n      return window.ipfs\n    } catch (er) {\n      await asyncWait(500)\n      return await this._ipfs()\n    }\n  }\n\n  static isCID = (cid: string | undefined | null): boolean => {\n    try {\n      if (!cid) return false\n      return isIPFS.multihash(cid)\n    } catch (er) {\n      return false\n    }\n  }\n\n  get = async (cid: string) => {\n    if (!IPFS.isCID(cid)) throw new Error('Invalid CID')\n    const ipfs = await this._ipfs()\n    const stream = await ipfs.cat(cid)\n    let raw = ''\n    for await (const chunk of stream) raw += Buffer.from(chunk).toString()\n    const data = JSON.parse(raw)\n    return data\n  }\n\n  set = async (data: object): Promise<string> => {\n    if (!data) throw new Error('Empty data')\n    const raw = JSON.stringify(data)\n    const ipfs = await this._ipfs()\n    const { cid } = await ipfs.add(raw)\n    return cid.toString()\n  }\n}\n\nexport default IPFS\n"],"names":["SOLVARS","spltAddress","splataAddress","devnet","node","rpc","swapAddress","taxmanAddress","platformFee","testnet","mainnet","DEFAULT_APP_ID","process","devApp","url","appId","name","author","email","tags","split","map","tag","trim","description","verified","development","devAppId","extra","senreg","staging","production","sol","net","register","env","devTools","appName","BigInt","prototype","toJSON","this","toString","bigintSerializationMiddleware","serializableCheck","isSerializable","val","Array","isArray","obj","proto","Object","getPrototypeOf","isPlainObject","PublicKey","BN","Buffer","isBuffer","NAME","getMint","createAsyncThunk","async","address","force","getState","account","Error","accounts","data","splt","window","sentre","getMintData","upsetMint","deleteMint","createSlice","initialState","reducers","extraReducers","builder","addCase","fulfilled","state","payload","assign","constructor","walletType","storage","transaction","transactions","message","signature","getProvider","disconnect","CloverWallet","BaseWallet","super","clover_solana","isCloverWallet","provider","getAccount","getAddress","publicKey","feePayer","signTransaction","forEach","signAllTransactions","encodedMsg","TextEncoder","encode","sig","signMessage","from","bufSig","nacl","toBuffer","collectFee","collectFees","Coin98Wallet","coin98","request","method","params","decode","addSignature","signatures","i","configs","target","memberName","descriptor","original","value","tx","ix","SystemProgram","fromPubkey","toPubkey","lamports","add","call","txs","GuestWallet","callback","_callback","_error","PhantomWallet","solana","isPhantom","isConnected","Promise","resolve","on","connect","KEY","driver","sessionStorage","convert","JSON","parse","e","session","set","key","getItem","setItem","stringify","get","clear","SecretKeyWallet","secretKey","password","setSecretKey","a","b","length","r","alloc","pwd","prompt","secretKeyString","getPassword","seed","hash","confusedSecretKey","xor","getSecretKey","keypair","toBase58","confirm","signData","serializeMessage","sign","push","SlopeWallet","Slope","msg","messages","slopeAddress","SolflareExtWallet","solflare","isSolflare","PROVIDER","WalletAdapter","SolflareWebWallet","connected","SolletWallet","PDB","walletAddress","dbName","ipfs","createInstance","localForage","storeName","dropInstance","instance","all","appIds","flat","concat","iterate","fetch","cid","backup","restore","IPFS","_ipfs","create","er","asyncWait","isCID","stream","cat","raw","chunk","isIPFS"],"sourceRoot":""}