{"version":3,"file":"static/js/vendors-node_modules_is-ipfs_src_index_js-node_modules_libp2p-crypto_src_pbkdf2_js-node_modul-7f16ed.becc8232.chunk.js","mappings":"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","sources":["../node_modules/is-ipfs/src/index.js","../node_modules/it-filter/index.js","../node_modules/it-map/index.js","../node_modules/it-merge/index.js","../node_modules/it-pipe/index.js","../node_modules/it-take/index.js","../node_modules/libp2p-crypto/src/pbkdf2.js","../node_modules/libp2p-crypto/src/random-bytes.js","../node_modules/datastore-core/esm/src/base.js","../node_modules/datastore-core/esm/src/errors.js","../node_modules/datastore-core/esm/src/keytransform.js","../node_modules/datastore-core/esm/src/memory.js","../node_modules/datastore-core/esm/src/mount.js","../node_modules/datastore-core/esm/src/namespace.js","../node_modules/datastore-core/esm/src/shard.js","../node_modules/datastore-core/esm/src/sharding.js","../node_modules/datastore-core/esm/src/tiered.js","../node_modules/datastore-core/esm/src/utils.js","../node_modules/interface-datastore/esm/src/key.js","../node_modules/ipfs-bitswap/esm/src/message/entry.js","../node_modules/ipfs-core-utils/esm/src/to-cid-and-path.js","../node_modules/multiformats/esm/src/bytes.js"],"sourcesContent":["'use strict'\n\nconst { base58btc } = require('multiformats/bases/base58')\nconst { base32 } = require('multiformats/bases/base32')\nconst Digest = require('multiformats/hashes/digest')\nconst { Multiaddr } = require('multiaddr')\nconst mafmt = require('mafmt')\nconst { CID } = require('multiformats/cid')\nconst { URL } = require('iso-url')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\n\nconst pathGatewayPattern = /^https?:\\/\\/[^/]+\\/(ip[fn]s)\\/([^/?#]+)/\nconst pathPattern = /^\\/(ip[fn]s)\\/([^/?#]+)/\nconst defaultProtocolMatch = 1\nconst defaultHashMath = 2\n\n// CID, libp2p-key or DNSLink\nconst subdomainGatewayPattern = /^https?:\\/\\/([^/]+)\\.(ip[fn]s)\\.[^/?]+/\nconst subdomainIdMatch = 1\nconst subdomainProtocolMatch = 2\n\n// Fully qualified domain name (FQDN) that has an explicit .tld suffix\nconst fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/\n\n/**\n * @param {*} hash\n */\nfunction isMultihash (hash) {\n  const formatted = convertToString(hash)\n  try {\n    Digest.decode(base58btc.decode('z' + formatted))\n  } catch {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {*} hash\n */\nfunction isBase32EncodedMultibase (hash) {\n  try {\n    base32.decode(hash)\n  } catch {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @param {*} hash\n */\nfunction isCID (hash) {\n  try {\n    if (typeof hash === 'string') {\n      return Boolean(CID.parse(hash))\n    }\n\n    if (hash instanceof Uint8Array) {\n      return Boolean(CID.decode(hash))\n    }\n\n    return Boolean(CID.asCID(hash)) // eslint-disable-line no-new\n  } catch (e) {\n    return false\n  }\n}\n\n/**\n * @param {*} input\n */\nfunction isMultiaddr (input) {\n  if (!input) return false\n  if (Multiaddr.isMultiaddr(input)) return true\n  try {\n    new Multiaddr(input) // eslint-disable-line no-new\n    return true\n  } catch (e) {\n    return false\n  }\n}\n\n/**\n * @param {string | Uint8Array | Multiaddr} input\n */\nfunction isPeerMultiaddr (input) {\n  return isMultiaddr(input) && mafmt.P2P.matches(input)\n}\n\n/**\n * @param {string | Uint8Array} input\n * @param {RegExp | string} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=2]\n */\nfunction isIpfs (input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {\n  const formatted = convertToString(input)\n  if (!formatted) {\n    return false\n  }\n\n  const match = formatted.match(pattern)\n  if (!match) {\n    return false\n  }\n\n  if (match[protocolMatch] !== 'ipfs') {\n    return false\n  }\n\n  let hash = match[hashMatch]\n\n  if (hash && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure hash is case-insensitive\n    // (browsers force-lowercase authority component anyway)\n    hash = hash.toLowerCase()\n  }\n\n  return isCID(hash)\n}\n\n/**\n *\n * @param {string | Uint8Array} input\n * @param {string | RegExp} pattern\n * @param {number} [protocolMatch=1]\n * @param {number} [hashMatch=1]\n */\nfunction isIpns (input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {\n  const formatted = convertToString(input)\n  if (!formatted) {\n    return false\n  }\n  const match = formatted.match(pattern)\n  if (!match) {\n    return false\n  }\n\n  if (match[protocolMatch] !== 'ipns') {\n    return false\n  }\n\n  let ipnsId = match[hashMatch]\n\n  if (ipnsId && pattern === subdomainGatewayPattern) {\n    // when doing checks for subdomain context\n    // ensure ipnsId is case-insensitive\n    // (browsers force-lowercase authority compotent anyway)\n    ipnsId = ipnsId.toLowerCase()\n    // Check if it is cidv1\n    if (isCID(ipnsId)) return true\n    // Check if it looks like FQDN\n    try {\n      if (!ipnsId.includes('.') && ipnsId.includes('-')) {\n        // name without tld, assuming its inlined into a single DNS label\n        // (https://github.com/ipfs/in-web-browsers/issues/169)\n        // en-wikipedia--on--ipfs-org â†’ en.wikipedia-on-ipfs.org\n        ipnsId = ipnsId.replace(/--/g, '@').replace(/-/g, '.').replace(/@/g, '-')\n      }\n      // URL implementation in web browsers forces lowercase of the hostname\n      const { hostname } = new URL(`http://${ipnsId}`) // eslint-disable-line no-new\n      // Check if potential FQDN has an explicit TLD\n      return fqdnWithTld.test(hostname)\n    } catch (e) {\n      return false\n    }\n  }\n\n  return true\n}\n\n/**\n * @param {any} input\n */\nfunction isString (input) {\n  return typeof input === 'string'\n}\n\n/**\n * @param {Uint8Array | string} input\n */\nfunction convertToString (input) {\n  if (input instanceof Uint8Array) {\n    return uint8ArrayToString(input, 'base58btc')\n  }\n\n  if (isString(input)) {\n    return input\n  }\n\n  return false\n}\n\n/**\n * @param {string | Uint8Array} url\n */\nconst ipfsSubdomain = (url) => isIpfs(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch)\n/**\n * @param {string | Uint8Array} url\n */\nconst ipnsSubdomain = (url) => isIpns(url, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch)\n/**\n * @param {string | Uint8Array} url\n */\nconst subdomain = (url) => ipfsSubdomain(url) || ipnsSubdomain(url)\n\n/**\n * @param {string | Uint8Array} url\n */\nconst ipfsUrl = (url) => isIpfs(url, pathGatewayPattern) || ipfsSubdomain(url)\n/**\n * @param {string | Uint8Array} url\n */\nconst ipnsUrl = (url) => isIpns(url, pathGatewayPattern) || ipnsSubdomain(url)\n/**\n * @param {string | Uint8Array} url\n */\nconst url = (url) => ipfsUrl(url) || ipnsUrl(url) || subdomain(url)\n\n/**\n * @param {string | Uint8Array} path\n */\nconst path = (path) => isIpfs(path, pathPattern) || isIpns(path, pathPattern)\n\nmodule.exports = {\n  multihash: isMultihash,\n  multiaddr: isMultiaddr,\n  peerMultiaddr: isPeerMultiaddr,\n  cid: isCID,\n  /**\n   * @param {CID | string | Uint8Array} cid\n   */\n  base32cid: (cid) => (isBase32EncodedMultibase(cid) && isCID(cid)),\n  ipfsSubdomain,\n  ipnsSubdomain,\n  subdomain,\n  subdomainGatewayPattern,\n  ipfsUrl,\n  ipnsUrl,\n  url,\n  pathGatewayPattern: pathGatewayPattern,\n  /**\n   * @param {string | Uint8Array} path\n   */\n  ipfsPath: (path) => isIpfs(path, pathPattern),\n  /**\n   * @param {string | Uint8Array} path\n   */\n  ipnsPath: (path) => isIpns(path, pathPattern),\n  path,\n  pathPattern,\n  /**\n   * @param {string | Uint8Array} x\n   */\n  urlOrPath: (x) => url(x) || path(x),\n  /**\n   * @param {string | Uint8Array | CID} path\n   */\n  cidPath: path => isString(path) && !isCID(path) && isIpfs(`/ipfs/${path}`, pathPattern)\n}\n","'use strict'\n\n/**\n * Filters the passed (async) iterable by using the filter function\n *\n * @template T\n * @param {AsyncIterable<T>|Iterable<T>} source\n * @param {function(T):boolean|Promise<boolean>} fn\n */\nconst filter = async function * (source, fn) {\n  for await (const entry of source) {\n    if (await fn(entry)) {\n      yield entry\n    }\n  }\n}\n\nmodule.exports = filter\n","'use strict'\n\n/**\n * Takes an (async) iterable and returns one with each item mapped by the passed\n * function.\n *\n * @template I,O\n * @param {AsyncIterable<I>|Iterable<I>} source\n * @param {function(I):O|Promise<O>} func\n * @returns {AsyncIterable<O>}\n */\nconst map = async function * (source, func) {\n  for await (const val of source) {\n    yield func(val)\n  }\n}\n\nmodule.exports = map\n","'use strict'\n\nconst pushable = require('it-pushable')\n\n/**\n * Treat one or more iterables as a single iterable.\n *\n * Nb. sources are iterated over in parallel so the\n * order of emitted items is not guaranteed.\n *\n * @template T\n * @param {...AsyncIterable<T>|Iterable<T>} sources\n * @returns {AsyncIterable<T>}\n */\nconst merge = async function * (...sources) {\n  const output = pushable()\n\n  setTimeout(async () => {\n    try {\n      await Promise.all(\n        sources.map(async (source) => {\n          for await (const item of source) {\n            output.push(item)\n          }\n        })\n      )\n\n      output.end()\n    } catch (/** @type {any} */ err) {\n      output.end(err)\n    }\n  }, 0)\n\n  yield * output\n}\n\nmodule.exports = merge\n","const rawPipe = (...fns) => {\n  let res\n  while (fns.length) {\n    res = fns.shift()(res)\n  }\n  return res\n}\n\nconst isIterable = obj => obj && (\n  typeof obj[Symbol.asyncIterator] === 'function' ||\n  typeof obj[Symbol.iterator] === 'function' ||\n  typeof obj.next === 'function' // Probably, right?\n)\n\nconst isDuplex = obj => obj && typeof obj.sink === 'function' && isIterable(obj.source)\n\nconst duplexPipelineFn = duplex => source => {\n  duplex.sink(source) // TODO: error on sink side is unhandled rejection - this is the same as pull streams\n  return duplex.source\n}\n\nconst pipe = (...fns) => {\n  // Duplex at start: wrap in function and return duplex source\n  if (isDuplex(fns[0])) {\n    const duplex = fns[0]\n    fns[0] = () => duplex.source\n  // Iterable at start: wrap in function\n  } else if (isIterable(fns[0])) {\n    const source = fns[0]\n    fns[0] = () => source\n  }\n\n  if (fns.length > 1) {\n    // Duplex at end: use duplex sink\n    if (isDuplex(fns[fns.length - 1])) {\n      fns[fns.length - 1] = fns[fns.length - 1].sink\n    }\n  }\n\n  if (fns.length > 2) {\n    // Duplex in the middle, consume source with duplex sink and return duplex source\n    for (let i = 1; i < fns.length - 1; i++) {\n      if (isDuplex(fns[i])) {\n        fns[i] = duplexPipelineFn(fns[i])\n      }\n    }\n  }\n\n  return rawPipe(...fns)\n}\n\nmodule.exports = pipe\nmodule.exports.pipe = pipe\nmodule.exports.rawPipe = rawPipe\nmodule.exports.isIterable = isIterable\nmodule.exports.isDuplex = isDuplex\n","'use strict'\n\n/**\n * Stop iteration after n items have been received.\n *\n * @template T\n * @param {AsyncIterable<T>|Iterable<T>} source\n * @param {number} limit\n * @returns {AsyncIterable<T>}\n */\nconst take = async function * (source, limit) {\n  let items = 0\n\n  if (limit < 1) {\n    return\n  }\n\n  for await (const entry of source) {\n    yield entry\n\n    items++\n\n    if (items === limit) {\n      return\n    }\n  }\n}\n\nmodule.exports = take\n","'use strict'\n\nconst forgePbkdf2 = require('node-forge/lib/pbkdf2')\nconst forgeUtil = require('node-forge/lib/util')\nconst errcode = require('err-code')\n\n/**\n * Maps an IPFS hash name to its node-forge equivalent.\n *\n * See https://github.com/multiformats/multihash/blob/master/hashtable.csv\n *\n * @private\n */\nconst hashName = {\n  sha1: 'sha1',\n  'sha2-256': 'sha256',\n  'sha2-512': 'sha512'\n}\n\n/**\n * Computes the Password-Based Key Derivation Function 2.\n *\n * @param {string} password\n * @param {string} salt\n * @param {number} iterations\n * @param {number} keySize - (in bytes)\n * @param {string} hash - The hash name ('sha1', 'sha2-512, ...)\n * @returns {string} - A new password\n */\nfunction pbkdf2 (password, salt, iterations, keySize, hash) {\n  const hasher = hashName[hash]\n  if (!hasher) {\n    const types = Object.keys(hashName).join(' / ')\n    throw errcode(new Error(`Hash '${hash}' is unknown or not supported. Must be ${types}`), 'ERR_UNSUPPORTED_HASH_TYPE')\n  }\n  const dek = forgePbkdf2(\n    password,\n    salt,\n    iterations,\n    keySize,\n    hasher)\n  return forgeUtil.encode64(dek)\n}\n\nmodule.exports = pbkdf2\n","'use strict'\nconst randomBytes = require('iso-random-stream/src/random')\nconst errcode = require('err-code')\n\nmodule.exports = function (length) {\n  if (isNaN(length) || length <= 0) {\n    throw errcode(new Error('random bytes length must be a Number bigger than 0'), 'ERR_INVALID_LENGTH')\n  }\n  return randomBytes(length)\n}\n","import { sortAll } from './utils.js';\nimport drain from 'it-drain';\nimport filter from 'it-filter';\nimport take from 'it-take';\nexport class BaseDatastore {\n  open() {\n    return Promise.reject(new Error('.open is not implemented'));\n  }\n  close() {\n    return Promise.reject(new Error('.close is not implemented'));\n  }\n  put(key, val, options) {\n    return Promise.reject(new Error('.put is not implemented'));\n  }\n  get(key, options) {\n    return Promise.reject(new Error('.get is not implemented'));\n  }\n  has(key, options) {\n    return Promise.reject(new Error('.has is not implemented'));\n  }\n  delete(key, options) {\n    return Promise.reject(new Error('.delete is not implemented'));\n  }\n  async *putMany(source, options = {}) {\n    for await (const {key, value} of source) {\n      await this.put(key, value, options);\n      yield {\n        key,\n        value\n      };\n    }\n  }\n  async *getMany(source, options = {}) {\n    for await (const key of source) {\n      yield this.get(key, options);\n    }\n  }\n  async *deleteMany(source, options = {}) {\n    for await (const key of source) {\n      await this.delete(key, options);\n      yield key;\n    }\n  }\n  batch() {\n    let puts = [];\n    let dels = [];\n    return {\n      put(key, value) {\n        puts.push({\n          key,\n          value\n        });\n      },\n      delete(key) {\n        dels.push(key);\n      },\n      commit: async options => {\n        await drain(this.putMany(puts, options));\n        puts = [];\n        await drain(this.deleteMany(dels, options));\n        dels = [];\n      }\n    };\n  }\n  async *_all(q, options) {\n    throw new Error('._all is not implemented');\n  }\n  async *_allKeys(q, options) {\n    throw new Error('._allKeys is not implemented');\n  }\n  query(q, options) {\n    let it = this._all(q, options);\n    if (q.prefix != null) {\n      it = filter(it, e => e.key.toString().startsWith(q.prefix));\n    }\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= q.offset);\n    }\n    if (q.limit != null) {\n      it = take(it, q.limit);\n    }\n    return it;\n  }\n  queryKeys(q, options) {\n    let it = this._allKeys(q, options);\n    if (q.prefix != null) {\n      it = filter(it, key => key.toString().startsWith(q.prefix));\n    }\n    if (Array.isArray(q.filters)) {\n      it = q.filters.reduce((it, f) => filter(it, f), it);\n    }\n    if (Array.isArray(q.orders)) {\n      it = q.orders.reduce((it, f) => sortAll(it, f), it);\n    }\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= q.offset);\n    }\n    if (q.limit != null) {\n      it = take(it, q.limit);\n    }\n    return it;\n  }\n}","import errCode from 'err-code';\nexport function dbOpenFailedError(err) {\n  err = err || new Error('Cannot open database');\n  return errCode(err, 'ERR_DB_OPEN_FAILED');\n}\nexport function dbDeleteFailedError(err) {\n  err = err || new Error('Delete failed');\n  return errCode(err, 'ERR_DB_DELETE_FAILED');\n}\nexport function dbWriteFailedError(err) {\n  err = err || new Error('Write failed');\n  return errCode(err, 'ERR_DB_WRITE_FAILED');\n}\nexport function notFoundError(err) {\n  err = err || new Error('Not Found');\n  return errCode(err, 'ERR_NOT_FOUND');\n}\nexport function abortedError(err) {\n  err = err || new Error('Aborted');\n  return errCode(err, 'ERR_ABORTED');\n}","import { BaseDatastore } from './base.js';\nimport map from 'it-map';\nimport { pipe } from 'it-pipe';\nexport class KeyTransformDatastore extends BaseDatastore {\n  constructor(child, transform) {\n    super();\n    this.child = child;\n    this.transform = transform;\n  }\n  open() {\n    return this.child.open();\n  }\n  put(key, val, options) {\n    return this.child.put(this.transform.convert(key), val, options);\n  }\n  get(key, options) {\n    return this.child.get(this.transform.convert(key), options);\n  }\n  has(key, options) {\n    return this.child.has(this.transform.convert(key), options);\n  }\n  delete(key, options) {\n    return this.child.delete(this.transform.convert(key), options);\n  }\n  async *putMany(source, options = {}) {\n    const transform = this.transform;\n    const child = this.child;\n    yield* pipe(source, async function* (source) {\n      yield* map(source, ({key, value}) => ({\n        key: transform.convert(key),\n        value\n      }));\n    }, async function* (source) {\n      yield* child.putMany(source, options);\n    }, async function* (source) {\n      yield* map(source, ({key, value}) => ({\n        key: transform.invert(key),\n        value\n      }));\n    });\n  }\n  async *getMany(source, options = {}) {\n    const transform = this.transform;\n    const child = this.child;\n    yield* pipe(source, async function* (source) {\n      yield* map(source, key => transform.convert(key));\n    }, async function* (source) {\n      yield* child.getMany(source, options);\n    });\n  }\n  async *deleteMany(source, options = {}) {\n    const transform = this.transform;\n    const child = this.child;\n    yield* pipe(source, async function* (source) {\n      yield* map(source, key => transform.convert(key));\n    }, async function* (source) {\n      yield* child.deleteMany(source, options);\n    }, async function* (source) {\n      yield* map(source, key => transform.invert(key));\n    });\n  }\n  batch() {\n    const b = this.child.batch();\n    return {\n      put: (key, value) => {\n        b.put(this.transform.convert(key), value);\n      },\n      delete: key => {\n        b.delete(this.transform.convert(key));\n      },\n      commit: options => {\n        return b.commit(options);\n      }\n    };\n  }\n  query(q, options) {\n    const query = { ...q };\n    query.filters = (query.filters || []).map(filter => {\n      return ({key, value}) => filter({\n        key: this.transform.convert(key),\n        value\n      });\n    });\n    const {prefix} = q;\n    if (prefix != null && prefix !== '/') {\n      delete query.prefix;\n      query.filters.push(({key}) => {\n        return this.transform.invert(key).toString().startsWith(prefix);\n      });\n    }\n    if (query.orders) {\n      query.orders = query.orders.map(order => {\n        return (a, b) => order({\n          key: this.transform.invert(a.key),\n          value: a.value\n        }, {\n          key: this.transform.invert(b.key),\n          value: b.value\n        });\n      });\n    }\n    return map(this.child.query(query, options), ({key, value}) => {\n      return {\n        key: this.transform.invert(key),\n        value\n      };\n    });\n  }\n  queryKeys(q, options) {\n    const query = { ...q };\n    query.filters = (query.filters || []).map(filter => {\n      return key => filter(this.transform.convert(key));\n    });\n    const {prefix} = q;\n    if (prefix != null && prefix !== '/') {\n      delete query.prefix;\n      query.filters.push(key => {\n        return this.transform.invert(key).toString().startsWith(prefix);\n      });\n    }\n    if (query.orders) {\n      query.orders = query.orders.map(order => {\n        return (a, b) => order(this.transform.invert(a), this.transform.invert(b));\n      });\n    }\n    return map(this.child.queryKeys(query, options), key => {\n      return this.transform.invert(key);\n    });\n  }\n  close() {\n    return this.child.close();\n  }\n}","import { BaseDatastore } from './base.js';\nimport { Key } from 'interface-datastore/key';\nimport * as Errors from './errors.js';\nexport class MemoryDatastore extends BaseDatastore {\n  constructor() {\n    super();\n    this.data = {};\n  }\n  open() {\n    return Promise.resolve();\n  }\n  close() {\n    return Promise.resolve();\n  }\n  async put(key, val) {\n    this.data[key.toString()] = val;\n  }\n  async get(key) {\n    const exists = await this.has(key);\n    if (!exists)\n      throw Errors.notFoundError();\n    return this.data[key.toString()];\n  }\n  async has(key) {\n    return this.data[key.toString()] !== undefined;\n  }\n  async delete(key) {\n    delete this.data[key.toString()];\n  }\n  async *_all() {\n    yield* Object.entries(this.data).map(([key, value]) => ({\n      key: new Key(key),\n      value\n    }));\n  }\n  async *_allKeys() {\n    yield* Object.entries(this.data).map(([key]) => new Key(key));\n  }\n}","import filter from 'it-filter';\nimport take from 'it-take';\nimport merge from 'it-merge';\nimport { BaseDatastore } from './base.js';\nimport * as Errors from './errors.js';\nimport { sortAll } from './utils.js';\nexport class MountDatastore extends BaseDatastore {\n  constructor(mounts) {\n    super();\n    this.mounts = mounts.slice();\n  }\n  async open() {\n    await Promise.all(this.mounts.map(m => m.datastore.open()));\n  }\n  _lookup(key) {\n    for (const mount of this.mounts) {\n      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {\n        return {\n          datastore: mount.datastore,\n          mountpoint: mount.prefix\n        };\n      }\n    }\n  }\n  put(key, value, options) {\n    const match = this._lookup(key);\n    if (match == null) {\n      throw Errors.dbWriteFailedError(new Error('No datastore mounted for this key'));\n    }\n    return match.datastore.put(key, value, options);\n  }\n  get(key, options) {\n    const match = this._lookup(key);\n    if (match == null) {\n      throw Errors.notFoundError(new Error('No datastore mounted for this key'));\n    }\n    return match.datastore.get(key, options);\n  }\n  has(key, options) {\n    const match = this._lookup(key);\n    if (match == null) {\n      return Promise.resolve(false);\n    }\n    return match.datastore.has(key, options);\n  }\n  delete(key, options) {\n    const match = this._lookup(key);\n    if (match == null) {\n      throw Errors.dbDeleteFailedError(new Error('No datastore mounted for this key'));\n    }\n    return match.datastore.delete(key, options);\n  }\n  async close() {\n    await Promise.all(this.mounts.map(m => {\n      return m.datastore.close();\n    }));\n  }\n  batch() {\n    const batchMounts = {};\n    const lookup = key => {\n      const match = this._lookup(key);\n      if (match == null) {\n        throw new Error('No datastore mounted for this key');\n      }\n      const m = match.mountpoint.toString();\n      if (batchMounts[m] == null) {\n        batchMounts[m] = match.datastore.batch();\n      }\n      return { batch: batchMounts[m] };\n    };\n    return {\n      put: (key, value) => {\n        const match = lookup(key);\n        match.batch.put(key, value);\n      },\n      delete: key => {\n        const match = lookup(key);\n        match.batch.delete(key);\n      },\n      commit: async options => {\n        await Promise.all(Object.keys(batchMounts).map(p => batchMounts[p].commit(options)));\n      }\n    };\n  }\n  query(q, options) {\n    const qs = this.mounts.map(m => {\n      return m.datastore.query({\n        prefix: q.prefix,\n        filters: q.filters\n      }, options);\n    });\n    let it = merge(...qs);\n    if (q.filters)\n      q.filters.forEach(f => {\n        it = filter(it, f);\n      });\n    if (q.orders)\n      q.orders.forEach(o => {\n        it = sortAll(it, o);\n      });\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= q.offset);\n    }\n    if (q.limit != null)\n      it = take(it, q.limit);\n    return it;\n  }\n  queryKeys(q, options) {\n    const qs = this.mounts.map(m => {\n      return m.datastore.queryKeys({\n        prefix: q.prefix,\n        filters: q.filters\n      }, options);\n    });\n    let it = merge(...qs);\n    if (q.filters)\n      q.filters.forEach(f => {\n        it = filter(it, f);\n      });\n    if (q.orders)\n      q.orders.forEach(o => {\n        it = sortAll(it, o);\n      });\n    if (q.offset != null) {\n      let i = 0;\n      it = filter(it, () => i++ >= q.offset);\n    }\n    if (q.limit != null)\n      it = take(it, q.limit);\n    return it;\n  }\n}","import { Key } from 'interface-datastore';\nimport { KeyTransformDatastore } from './keytransform.js';\nexport class NamespaceDatastore extends KeyTransformDatastore {\n  constructor(child, prefix) {\n    super(child, {\n      convert(key) {\n        return prefix.child(key);\n      },\n      invert(key) {\n        if (prefix.toString() === '/') {\n          return key;\n        }\n        if (!prefix.isAncestorOf(key)) {\n          throw new Error(`Expected prefix: (${ prefix.toString() }) in key: ${ key.toString() }`);\n        }\n        return new Key(key.toString().slice(prefix.toString().length), false);\n      }\n    });\n  }\n}","import { Key } from 'interface-datastore/key';\nimport readme from './shard-readme.js';\nexport const PREFIX = '/repo/flatfs/shard/';\nexport const SHARDING_FN = 'SHARDING';\nexport const README_FN = '_README';\nexport class ShardBase {\n  constructor(param) {\n    this.param = param;\n    this.name = 'base';\n    this._padding = '';\n  }\n  fun(s) {\n    return 'implement me';\n  }\n  toString() {\n    return `${ PREFIX }v1/${ this.name }/${ this.param }`;\n  }\n}\nexport class Prefix extends ShardBase {\n  constructor(prefixLen) {\n    super(prefixLen);\n    this._padding = ''.padStart(prefixLen, '_');\n    this.name = 'prefix';\n  }\n  fun(noslash) {\n    return (noslash + this._padding).slice(0, this.param);\n  }\n}\nexport class Suffix extends ShardBase {\n  constructor(suffixLen) {\n    super(suffixLen);\n    this._padding = ''.padStart(suffixLen, '_');\n    this.name = 'suffix';\n  }\n  fun(noslash) {\n    const s = this._padding + noslash;\n    return s.slice(s.length - this.param);\n  }\n}\nexport class NextToLast extends ShardBase {\n  constructor(suffixLen) {\n    super(suffixLen);\n    this._padding = ''.padStart(suffixLen + 1, '_');\n    this.name = 'next-to-last';\n  }\n  fun(noslash) {\n    const s = this._padding + noslash;\n    const offset = s.length - this.param - 1;\n    return s.slice(offset, offset + this.param);\n  }\n}\nexport function parseShardFun(str) {\n  str = str.trim();\n  if (str.length === 0) {\n    throw new Error('empty shard string');\n  }\n  if (!str.startsWith(PREFIX)) {\n    throw new Error(`invalid or no path prefix: ${ str }`);\n  }\n  const parts = str.slice(PREFIX.length).split('/');\n  const version = parts[0];\n  if (version !== 'v1') {\n    throw new Error(`expect 'v1' version, got '${ version }'`);\n  }\n  const name = parts[1];\n  if (!parts[2]) {\n    throw new Error('missing param');\n  }\n  const param = parseInt(parts[2], 10);\n  switch (name) {\n  case 'prefix':\n    return new Prefix(param);\n  case 'suffix':\n    return new Suffix(param);\n  case 'next-to-last':\n    return new NextToLast(param);\n  default:\n    throw new Error(`unkown sharding function: ${ name }`);\n  }\n}\nexport const readShardFun = async (path, store) => {\n  const key = new Key(path).child(new Key(SHARDING_FN));\n  const get = typeof store.getRaw === 'function' ? store.getRaw.bind(store) : store.get.bind(store);\n  const res = await get(key);\n  return parseShardFun(new TextDecoder().decode(res || '').trim());\n};\nexport {\n  default as readme\n} from './shard-readme.js';","import { Key } from 'interface-datastore';\nimport {\n  readShardFun,\n  SHARDING_FN,\n  README_FN,\n  readme\n} from './shard.js';\nimport { BaseDatastore } from './base.js';\nimport { KeyTransformDatastore } from './keytransform.js';\nimport * as Errors from './errors.js';\nconst shardKey = new Key(SHARDING_FN);\nconst shardReadmeKey = new Key(README_FN);\nexport class ShardingDatastore extends BaseDatastore {\n  constructor(store, shard) {\n    super();\n    this.child = new KeyTransformDatastore(store, {\n      convert: this._convertKey.bind(this),\n      invert: this._invertKey.bind(this)\n    });\n    this.shard = shard;\n  }\n  async open() {\n    await this.child.open();\n    this.shard = await ShardingDatastore.create(this.child, this.shard);\n  }\n  _convertKey(key) {\n    const s = key.toString();\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n    const parent = new Key(this.shard.fun(s));\n    return parent.child(key);\n  }\n  _invertKey(key) {\n    const s = key.toString();\n    if (s === shardKey.toString() || s === shardReadmeKey.toString()) {\n      return key;\n    }\n    return Key.withNamespaces(key.list().slice(1));\n  }\n  static async createOrOpen(store, shard) {\n    try {\n      await ShardingDatastore.create(store, shard);\n    } catch (err) {\n      if (err && err.message !== 'datastore exists')\n        throw err;\n    }\n    return ShardingDatastore.open(store);\n  }\n  static async open(store) {\n    const shard = await readShardFun('/', store);\n    return new ShardingDatastore(store, shard);\n  }\n  static async create(store, shard) {\n    const hasShard = await store.has(shardKey);\n    if (!hasShard && !shard) {\n      throw Errors.dbOpenFailedError(Error('Shard is required when datastore doesn\\'t have a shard key already.'));\n    }\n    if (!hasShard) {\n      const put = typeof store.putRaw === 'function' ? store.putRaw.bind(store) : store.put.bind(store);\n      await Promise.all([\n        put(shardKey, new TextEncoder().encode(shard.toString() + '\\n')),\n        put(shardReadmeKey, new TextEncoder().encode(readme))\n      ]);\n      return shard;\n    }\n    const diskShard = await readShardFun('/', store);\n    const a = (diskShard || '').toString();\n    const b = shard.toString();\n    if (a !== b) {\n      throw new Error(`specified fun ${ b } does not match repo shard fun ${ a }`);\n    }\n    return diskShard;\n  }\n  put(key, val, options) {\n    return this.child.put(key, val, options);\n  }\n  get(key, options) {\n    return this.child.get(key, options);\n  }\n  has(key, options) {\n    return this.child.has(key, options);\n  }\n  delete(key, options) {\n    return this.child.delete(key, options);\n  }\n  async *putMany(source, options = {}) {\n    yield* this.child.putMany(source, options);\n  }\n  async *getMany(source, options = {}) {\n    yield* this.child.getMany(source, options);\n  }\n  async *deleteMany(source, options = {}) {\n    yield* this.child.deleteMany(source, options);\n  }\n  batch() {\n    return this.child.batch();\n  }\n  query(q, options) {\n    const tq = {\n      ...q,\n      filters: [\n        ({key}) => key.toString() !== shardKey.toString(),\n        ({key}) => key.toString() !== shardReadmeKey.toString()\n      ].concat(q.filters || [])\n    };\n    return this.child.query(tq, options);\n  }\n  queryKeys(q, options) {\n    const tq = {\n      ...q,\n      filters: [\n        key => key.toString() !== shardKey.toString(),\n        key => key.toString() !== shardReadmeKey.toString()\n      ].concat(q.filters || [])\n    };\n    return this.child.queryKeys(tq, options);\n  }\n  close() {\n    return this.child.close();\n  }\n}","import { BaseDatastore } from './base.js';\nimport * as Errors from './errors.js';\nimport debug from 'debug';\nimport pushable from 'it-pushable';\nimport drain from 'it-drain';\nconst log = debug('datastore:core:tiered');\nexport class TieredDatastore extends BaseDatastore {\n  constructor(stores) {\n    super();\n    this.stores = stores.slice();\n  }\n  async open() {\n    try {\n      await Promise.all(this.stores.map(store => store.open()));\n    } catch (err) {\n      throw Errors.dbOpenFailedError();\n    }\n  }\n  async put(key, value) {\n    try {\n      await Promise.all(this.stores.map(store => store.put(key, value)));\n    } catch (err) {\n      throw Errors.dbWriteFailedError();\n    }\n  }\n  async get(key, options) {\n    for (const store of this.stores) {\n      try {\n        const res = await store.get(key, options);\n        if (res)\n          return res;\n      } catch (err) {\n        log(err);\n      }\n    }\n    throw Errors.notFoundError();\n  }\n  async has(key, options) {\n    for (const s of this.stores) {\n      if (await s.has(key, options)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  async delete(key, options) {\n    try {\n      await Promise.all(this.stores.map(store => store.delete(key, options)));\n    } catch (err) {\n      throw Errors.dbDeleteFailedError();\n    }\n  }\n  async *putMany(source, options = {}) {\n    let error;\n    const pushables = this.stores.map(store => {\n      const source = pushable();\n      drain(store.putMany(source, options)).catch(err => {\n        error = err;\n      });\n      return source;\n    });\n    try {\n      for await (const pair of source) {\n        if (error) {\n          throw error;\n        }\n        pushables.forEach(p => p.push(pair));\n        yield pair;\n      }\n    } finally {\n      pushables.forEach(p => p.end());\n    }\n  }\n  async *deleteMany(source, options = {}) {\n    let error;\n    const pushables = this.stores.map(store => {\n      const source = pushable();\n      drain(store.deleteMany(source, options)).catch(err => {\n        error = err;\n      });\n      return source;\n    });\n    try {\n      for await (const key of source) {\n        if (error) {\n          throw error;\n        }\n        pushables.forEach(p => p.push(key));\n        yield key;\n      }\n    } finally {\n      pushables.forEach(p => p.end());\n    }\n  }\n  async close() {\n    await Promise.all(this.stores.map(store => store.close()));\n  }\n  batch() {\n    const batches = this.stores.map(store => store.batch());\n    return {\n      put: (key, value) => {\n        batches.forEach(b => b.put(key, value));\n      },\n      delete: key => {\n        batches.forEach(b => b.delete(key));\n      },\n      commit: async options => {\n        for (const batch of batches) {\n          await batch.commit(options);\n        }\n      }\n    };\n  }\n  query(q, options) {\n    return this.stores[this.stores.length - 1].query(q, options);\n  }\n  queryKeys(q, options) {\n    return this.stores[this.stores.length - 1].queryKeys(q, options);\n  }\n}","import all from 'it-all';\nexport const sortAll = (iterable, sorter) => {\n  return async function* () {\n    const values = await all(iterable);\n    yield* values.sort(sorter);\n  }();\n};\nexport const replaceStartWith = (s, r) => {\n  const matcher = new RegExp('^' + r);\n  return s.replace(matcher, '');\n};","import { nanoid } from 'nanoid';\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string';\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';\nconst pathSepS = '/';\nconst pathSepB = new TextEncoder().encode(pathSepS);\nconst pathSep = pathSepB[0];\nexport class Key {\n  constructor(s, clean) {\n    if (typeof s === 'string') {\n      this._buf = uint8ArrayFromString(s);\n    } else if (s instanceof Uint8Array) {\n      this._buf = s;\n    } else {\n      throw new Error('Invalid key, should be String of Uint8Array');\n    }\n    if (clean == null) {\n      clean = true;\n    }\n    if (clean) {\n      this.clean();\n    }\n    if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {\n      throw new Error('Invalid key');\n    }\n  }\n  toString(encoding = 'utf8') {\n    return uint8ArrayToString(this._buf, encoding);\n  }\n  uint8Array() {\n    return this._buf;\n  }\n  get [Symbol.toStringTag]() {\n    return `Key(${ this.toString() })`;\n  }\n  static withNamespaces(list) {\n    return new Key(list.join(pathSepS));\n  }\n  static random() {\n    return new Key(nanoid().replace(/-/g, ''));\n  }\n  static asKey(other) {\n    if (other instanceof Uint8Array || typeof other === 'string') {\n      return new Key(other);\n    }\n    if (other.uint8Array) {\n      return new Key(other.uint8Array());\n    }\n    return null;\n  }\n  clean() {\n    if (!this._buf || this._buf.byteLength === 0) {\n      this._buf = pathSepB;\n    }\n    if (this._buf[0] !== pathSep) {\n      const bytes = new Uint8Array(this._buf.byteLength + 1);\n      bytes.fill(pathSep, 0, 1);\n      bytes.set(this._buf, 1);\n      this._buf = bytes;\n    }\n    while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {\n      this._buf = this._buf.subarray(0, -1);\n    }\n  }\n  less(key) {\n    const list1 = this.list();\n    const list2 = key.list();\n    for (let i = 0; i < list1.length; i++) {\n      if (list2.length < i + 1) {\n        return false;\n      }\n      const c1 = list1[i];\n      const c2 = list2[i];\n      if (c1 < c2) {\n        return true;\n      } else if (c1 > c2) {\n        return false;\n      }\n    }\n    return list1.length < list2.length;\n  }\n  reverse() {\n    return Key.withNamespaces(this.list().slice().reverse());\n  }\n  namespaces() {\n    return this.list();\n  }\n  baseNamespace() {\n    const ns = this.namespaces();\n    return ns[ns.length - 1];\n  }\n  list() {\n    return this.toString().split(pathSepS).slice(1);\n  }\n  type() {\n    return namespaceType(this.baseNamespace());\n  }\n  name() {\n    return namespaceValue(this.baseNamespace());\n  }\n  instance(s) {\n    return new Key(this.toString() + ':' + s);\n  }\n  path() {\n    let p = this.parent().toString();\n    if (!p.endsWith(pathSepS)) {\n      p += pathSepS;\n    }\n    p += this.type();\n    return new Key(p);\n  }\n  parent() {\n    const list = this.list();\n    if (list.length === 1) {\n      return new Key(pathSepS);\n    }\n    return new Key(list.slice(0, -1).join(pathSepS));\n  }\n  child(key) {\n    if (this.toString() === pathSepS) {\n      return key;\n    } else if (key.toString() === pathSepS) {\n      return this;\n    }\n    return new Key(this.toString() + key.toString(), false);\n  }\n  isAncestorOf(other) {\n    if (other.toString() === this.toString()) {\n      return false;\n    }\n    return other.toString().startsWith(this.toString());\n  }\n  isDecendantOf(other) {\n    if (other.toString() === this.toString()) {\n      return false;\n    }\n    return this.toString().startsWith(other.toString());\n  }\n  isTopLevel() {\n    return this.list().length === 1;\n  }\n  concat(...keys) {\n    return Key.withNamespaces([\n      ...this.namespaces(),\n      ...flatten(keys.map(key => key.namespaces()))\n    ]);\n  }\n}\nfunction namespaceType(ns) {\n  const parts = ns.split(':');\n  if (parts.length < 2) {\n    return '';\n  }\n  return parts.slice(0, -1).join(':');\n}\nfunction namespaceValue(ns) {\n  const parts = ns.split(':');\n  return parts[parts.length - 1];\n}\nfunction flatten(arr) {\n  return [].concat(...arr);\n}","import { Wantlist } from '../wantlist/index.js';\nimport { base58btc } from 'multiformats/bases/base58';\nconst WantlistEntry = Wantlist.Entry;\nexport class BitswapMessageEntry {\n  constructor(cid, priority, wantType, cancel, sendDontHave) {\n    this.entry = new WantlistEntry(cid, priority, wantType);\n    this.cancel = Boolean(cancel);\n    this.sendDontHave = Boolean(sendDontHave);\n  }\n  get cid() {\n    return this.entry.cid;\n  }\n  set cid(cid) {\n    this.entry.cid = cid;\n  }\n  get priority() {\n    return this.entry.priority;\n  }\n  set priority(val) {\n    this.entry.priority = val;\n  }\n  get wantType() {\n    return this.entry.wantType;\n  }\n  set wantType(val) {\n    this.entry.wantType = val;\n  }\n  get [Symbol.toStringTag]() {\n    const cidStr = this.cid.toString(base58btc);\n    return `BitswapMessageEntry ${ cidStr } <cancel: ${ this.cancel }, priority: ${ this.priority }>`;\n  }\n  equals(other) {\n    return this.cancel === other.cancel && this.sendDontHave === other.sendDontHave && this.wantType === other.wantType && this.entry.equals(other.entry);\n  }\n}","import { CID } from 'multiformats/cid';\nimport errCode from 'err-code';\nconst IPFS_PREFIX = '/ipfs/';\nexport function toCidAndPath(string) {\n  if (string instanceof Uint8Array) {\n    try {\n      string = CID.decode(string);\n    } catch (err) {\n      throw errCode(err, 'ERR_INVALID_CID');\n    }\n  }\n  let cid = CID.asCID(string);\n  if (cid) {\n    return {\n      cid,\n      path: undefined\n    };\n  }\n  string = string.toString();\n  if (string.startsWith(IPFS_PREFIX)) {\n    string = string.substring(IPFS_PREFIX.length);\n  }\n  const parts = string.split('/');\n  let path;\n  try {\n    cid = CID.parse(parts.shift() || '');\n  } catch (err) {\n    throw errCode(err, 'ERR_INVALID_CID');\n  }\n  if (parts.length) {\n    path = `/${ parts.join('/') }`;\n  }\n  return {\n    cid,\n    path\n  };\n}","const empty = new Uint8Array(0);\nconst toHex = d => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '');\nconst fromHex = hex => {\n  const hexes = hex.match(/../g);\n  return hexes ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty;\n};\nconst equals = (aa, bb) => {\n  if (aa === bb)\n    return true;\n  if (aa.byteLength !== bb.byteLength) {\n    return false;\n  }\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false;\n    }\n  }\n  return true;\n};\nconst coerce = o => {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array')\n    return o;\n  if (o instanceof ArrayBuffer)\n    return new Uint8Array(o);\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);\n  }\n  throw new Error('Unknown type, must be binary type');\n};\nconst isBinary = o => o instanceof ArrayBuffer || ArrayBuffer.isView(o);\nconst fromString = str => new TextEncoder().encode(str);\nconst toString = b => new TextDecoder().decode(b);\nexport {\n  equals,\n  coerce,\n  isBinary,\n  fromHex,\n  toHex,\n  fromString,\n  toString,\n  empty\n};"],"names":["base58btc","require","base32","Digest","Multiaddr","mafmt","CID","URL","toString","uint8ArrayToString","pathGatewayPattern","pathPattern","subdomainGatewayPattern","fqdnWithTld","isCID","hash","Boolean","parse","Uint8Array","decode","asCID","e","isMultiaddr","input","isIpfs","pattern","protocolMatch","hashMatch","formatted","convertToString","match","toLowerCase","isIpns","ipnsId","includes","replace","hostname","test","isString","ipfsSubdomain","url","ipnsSubdomain","subdomain","ipfsUrl","ipnsUrl","path","module","exports","multihash","multiaddr","peerMultiaddr","P2P","matches","cid","base32cid","isBase32EncodedMultibase","ipfsPath","ipnsPath","urlOrPath","x","cidPath","async","source","fn","entry","func","val","pushable","sources","output","setTimeout","Promise","all","map","item","push","end","err","rawPipe","res","fns","length","shift","isIterable","obj","Symbol","asyncIterator","iterator","next","isDuplex","sink","duplexPipelineFn","duplex","pipe","i","limit","items","forgePbkdf2","forgeUtil","errcode","hashName","sha1","password","salt","iterations","keySize","hasher","types","Object","keys","join","Error","dek","encode64","randomBytes","isNaN","BaseDatastore","open","reject","close","put","key","options","get","has","delete","value","this","batch","puts","dels","commit","drain","putMany","deleteMany","q","query","it","_all","prefix","filter","startsWith","Array","isArray","filters","reduce","f","orders","sortAll","offset","take","queryKeys","_allKeys","dbOpenFailedError","errCode","dbDeleteFailedError","dbWriteFailedError","notFoundError","abortedError","KeyTransformDatastore","constructor","child","transform","super","convert","invert","getMany","b","order","a","MemoryDatastore","data","resolve","Errors","undefined","entries","Key","MountDatastore","mounts","slice","m","datastore","_lookup","mount","isAncestorOf","mountpoint","batchMounts","lookup","p","qs","merge","forEach","o","NamespaceDatastore","PREFIX","SHARDING_FN","README_FN","ShardBase","param","name","_padding","fun","s","Prefix","prefixLen","padStart","noslash","Suffix","suffixLen","NextToLast","parseShardFun","str","trim","parts","split","version","parseInt","readShardFun","store","getRaw","bind","TextDecoder","shardKey","shardReadmeKey","ShardingDatastore","shard","_convertKey","_invertKey","create","list","message","hasShard","putRaw","TextEncoder","encode","readme","diskShard","tq","concat","log","debug","TieredDatastore","stores","error","pushables","catch","pair","batches","iterable","sorter","values","sort","pathSepS","pathSepB","pathSep","clean","_buf","uint8ArrayFromString","byteLength","encoding","uint8Array","toStringTag","nanoid","other","bytes","fill","set","subarray","less","list1","list2","c1","c2","reverse","withNamespaces","namespaces","baseNamespace","ns","type","namespaceType","namespaceValue","instance","parent","endsWith","isDecendantOf","isTopLevel","arr","WantlistEntry","Wantlist","BitswapMessageEntry","priority","wantType","cancel","sendDontHave","equals","IPFS_PREFIX","toCidAndPath","string","substring","empty","toHex","d","hex","byte","fromHex","hexes","aa","bb","ii","coerce","ArrayBuffer","isView","buffer","byteOffset","isBinary","fromString"],"sourceRoot":""}